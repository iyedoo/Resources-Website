# The AOI Roadmap

This roadmap is a **recommended learning path** for AOI students who want to gradually build their competitive programming and problem-solving skills.  

âš ï¸ **Important:**  

- Focus on **problem-solving skills** more than rushing to advance in the roadmap.  
- Make sure your **basics are strong** before moving on.  
- You are not obliged to complete the whole roadmap â€” it is just a **suggestion of what to do next**.  
- **Practice a lot** â€” solving problems consistently is the most effective way to improve.  
- Learn to **write clean solutions and explain your reasoning** â€” clarity is as important as correctness.  
- Always review your mistakes and **analyze why a solution failed** â€” this is where the real learning happens.  

---

## Phase 1 â€“ Foundations

- [Language basics (C++): I/O, loops, conditionals, functions](fundamentals/intro-to-c%2B%2B.md)  
- [Complexity analysis (Big-O, simple cases)](fundamentals/time-complexity.md)
- Basic math: logic, gcd, lcm, primes, modular arithmetic, sequences  
- Arrays & strings basics  
- Problem-solving mindset (reading problems, testing with examples)  
- Debugging practices  
- [Introduction to proof writing in mathematics](math/proof-writing.md)  

---

## Phase 2 â€“ First Data Structures & Problem-Solving Tools

- Prefix sums, difference arrays  
- Stacks, queues, deques, linked lists  
- `std::sort`, custom comparators  
- Two pointers  
- Simple greedy strategies + proof of correctness + Mathematical Induction  
- Geometry basics: Dot/Cross Product, Manhattan Distance, Euclidean Distance  
- Floating point number representation  
- Radix conversion  
- Binary search on arrays  

---

## Phase 3 â€“ Brute Force, Recursion & Intro to Graphs/DP

- Brute force & complexity limits  
- Sorting techniques: $O(n^2)$ sorts, Radix sort, Bucket sort  
- Backtracking (N-queens, permutations)  
- Recursion (factorial, Fibonacci, tree traversal)  
- Bitmasks for subsets  
- Divisibility, Sieve of Eratosthenes, factorization in $O(\sqrt{n})$  
- Binary search on answer  
- Binary exponentiation  
- Interactive problems  
- Intro to DP: Fibonacci, Coin Change  
- Graph representation: adjacency list vs. matrix  
- Connected components  

---

## Phase 4 â€“ Intermediate DS & DP

- Sets, multisets, hashmaps, policy-based DS  
- Coordinate compression  
- Pointers & Iterators  
- Trees (DFS, BFS, properties, DP)  
- Tries  
- Intermediate DP:  
    * Grid paths  
    * Prefix DP  
    * 0/1 Knapsack  
    * Interval DP (matrix chain, merging stones)  
    * LIS (Longest Increasing Subsequence)  
- Counting & combinatorics basics (nCr, Pascalâ€™s triangle, factorials mod, Binomial Theorem)  
- Game Theory Basics & Minimax  
- Line sweeping  

---

## Phase 5 â€“ Graph Algorithms (Part I)

- BFS, DFS in depth  
- Planar Graphs, Eulerian Graphs, Hamiltonian Graphs  
- Topological Sort & Euler Tour  
- Shortest paths:  
    * Dijkstra  
    * Bellmanâ€“Ford  
    * Floydâ€“Warshall  

---

## Phase 6 â€“ Divide & Conquer, Trees & DS

- Fast sorting (merge sort, quick sort)  
- Divide & conquer on problems (inversion count, Karatsuba multiplication)  
- Sparse tables, Segment Trees, Fenwick Tree, Merge Sort Tree  
- Binary heaps  
- Union-Find (DSU)  

---

## Phase 7 â€“ Advanced Graph Algorithms

- Minimum Spanning Tree (Kruskal, Prim)  
- Binary Lifting (LCA)  
- Strongly Connected Components & Condensation graph  
- Flows (Fordâ€“Fulkerson)  
- Bipartite Matching, Hungarian Algorithm  
- More interactive problems  
- Bridges & Articulation Points  

---

## Phase 8 â€“ Advanced Topics

- Persistent Data Structures  
- Advanced Number Theory
    * Fermatâ€™s Little Theorem  
    * Eulerâ€™s Totient Function  
    * BÃ©zoutâ€™s Identity  
    * Modular inverses  
- Ternary search (unimodal functions)  
- Sqrt decomposition & Moâ€™s algorithm  
- Heavy-light decomposition  
- Centroid decomposition  
- Knuthâ€“Yao optimization  
- Randomized Algorithms  
- Lazy propagation  
- Geometry:  
    * Convex hull  
    * Rotations & angle problems  
    * Polygon area  

---

## Final Tips

- **Consistency beats intensity**: Solve a few problems every day rather than cramming.  
- **Mix topics**: Donâ€™t stay stuck on only one topic for months; revisit earlier phases to reinforce them.  
- **Balance theory and practice**: Understanding algorithms is important, but solving problems under time pressure matters more.  
- **Compete often**: Join Codeforces, AtCoder, and AOI contests regularly to measure your progress.  
- **Discuss with peers**: Teaching or explaining a solution to a friend helps you deeply understand it.  
- **Donâ€™t fear hard problems**: Even if you canâ€™t solve them, trying will push your thinking forward.  

> ðŸš€ Remember: becoming strong at problem-solving is not about how **fast** you progress through the roadmap, but how **deeply** you understand and apply each step.  

