import{_ as t,c as a,o as i,ah as o}from"./chunks/framework.B49HbWsY.js";const u=JSON.parse('{"title":"Problem-Solving Guide","description":"","frontmatter":{},"headers":[],"relativePath":"fundamentals/problem-solving.md","filePath":"fundamentals/problem-solving.md"}'),n={name:"fundamentals/problem-solving.md"};function r(s,e,l,p,h,d){return i(),a("div",null,[...e[0]||(e[0]=[o(`<h1 id="problem-solving-guide" tabindex="-1">Problem-Solving Guide <a class="header-anchor" href="#problem-solving-guide" aria-label="Permalink to &quot;Problem-Solving Guide&quot;">‚Äã</a></h1><p>Mastering competitive programming isn&#39;t about memorizing algorithms ‚Äî it&#39;s about developing <strong>systematic thinking habits</strong> and <strong>disciplined problem-solving techniques</strong>. This guide provides a proven framework that transforms chaotic problem-solving into a structured, repeatable process.</p><hr><h2 id="üéØ-the-golden-rule-think-first-code-last" tabindex="-1">üéØ The Golden Rule: Think First, Code Last <a class="header-anchor" href="#üéØ-the-golden-rule-think-first-code-last" aria-label="Permalink to &quot;üéØ The Golden Rule: Think First, Code Last&quot;">‚Äã</a></h2><p><strong>90% of your time should be spent understanding and planning. Only 10% should be spent coding.</strong></p><p>Most programmers fail because they rush to code before they truly understand the problem. This guide will teach you to resist that urge and develop the discipline of top-tier competitive programmers.</p><hr><h2 id="phase-1-üìñ-deep-problem-understanding" tabindex="-1">Phase 1: üìñ Deep Problem Understanding <a class="header-anchor" href="#phase-1-üìñ-deep-problem-understanding" aria-label="Permalink to &quot;Phase 1: üìñ Deep Problem Understanding&quot;">‚Äã</a></h2><h3 id="step-1-the-two-read-rule" tabindex="-1">Step 1: The Two-Read Rule <a class="header-anchor" href="#step-1-the-two-read-rule" aria-label="Permalink to &quot;Step 1: The Two-Read Rule&quot;">‚Äã</a></h3><ul><li><strong>First read</strong>: Get the general idea. Don&#39;t worry about details yet.</li><li><strong>Second read</strong>: Focus on specifics. Underline or highlight key information.</li></ul><h3 id="step-2-extract-the-core-elements" tabindex="-1">Step 2: Extract the Core Elements <a class="header-anchor" href="#step-2-extract-the-core-elements" aria-label="Permalink to &quot;Step 2: Extract the Core Elements&quot;">‚Äã</a></h3><p>Ask these questions and write down the answers:</p><p><strong>Input Analysis:</strong></p><ul><li>What exactly am I given?</li><li>What&#39;s the format? (single line, multiple test cases, etc.)</li><li>What are the data types? (integers, strings, arrays, etc.)</li></ul><p><strong>Output Analysis:</strong></p><ul><li>What exactly should I produce?</li><li>What&#39;s the exact format? (spaces between numbers? newlines? case-sensitive?)</li><li>Are there special cases for the output?</li></ul><p><strong>Constraints Analysis:</strong></p><ul><li>What are the limits on input size?</li><li>What are the value ranges?</li><li>How much time do I have? (usually 1-2 seconds)</li></ul><h3 id="step-3-constraint-driven-complexity-planning" tabindex="-1">Step 3: Constraint-Driven Complexity Planning <a class="header-anchor" href="#step-3-constraint-driven-complexity-planning" aria-label="Permalink to &quot;Step 3: Constraint-Driven Complexity Planning&quot;">‚Äã</a></h3><p>Use this table to guide your approach:</p><table tabindex="0"><thead><tr><th>Size</th><th>Time Complexity</th><th>Approach</th></tr></thead><tbody><tr><td>n ‚â§ 10</td><td>Any approach works</td><td>Brute force, recursion</td></tr><tr><td>n ‚â§ 100</td><td>O(n¬≤) or O(n¬≥)</td><td>Nested loops, simple DP</td></tr><tr><td>n ‚â§ 1,000</td><td>O(n¬≤)</td><td>Two nested loops max</td></tr><tr><td>n ‚â§ 10,000</td><td>O(n log n) or O(n‚àön)</td><td>Sorting, optimized algorithms</td></tr><tr><td>n ‚â§ 100,000</td><td>O(n log n)</td><td>Sorting, segment trees, binary search</td></tr><tr><td>n ‚â§ 1,000,000</td><td>O(n) or O(n log log n)</td><td>Linear algorithms, sieve</td></tr><tr><td>n &gt; 1,000,000</td><td>O(log n) or O(1)</td><td>Math formulas, precomputation</td></tr></tbody></table><hr><h2 id="phase-2-‚úçÔ∏è-paper-based-problem-solving" tabindex="-1">Phase 2: ‚úçÔ∏è Paper-Based Problem Solving <a class="header-anchor" href="#phase-2-‚úçÔ∏è-paper-based-problem-solving" aria-label="Permalink to &quot;Phase 2: ‚úçÔ∏è Paper-Based Problem Solving&quot;">‚Äã</a></h2><p><strong>This is where champions are made.</strong> Never skip this phase.</p><h3 id="step-1-restate-the-problem" tabindex="-1">Step 1: Restate the Problem <a class="header-anchor" href="#step-1-restate-the-problem" aria-label="Permalink to &quot;Step 1: Restate the Problem&quot;">‚Äã</a></h3><p>Write the problem in your own words in 1-2 sentences. This forces true understanding.</p><p><em>Example: &quot;Given an array of integers, find the second-largest unique value.&quot;</em></p><h3 id="step-2-manual-sample-tracing" tabindex="-1">Step 2: Manual Sample Tracing <a class="header-anchor" href="#step-2-manual-sample-tracing" aria-label="Permalink to &quot;Step 2: Manual Sample Tracing&quot;">‚Äã</a></h3><p>For each given example:</p><ol><li>Write the input clearly</li><li>Step through your mental process</li><li>Verify you get the expected output</li><li>If not, re-read the problem‚Äîyou misunderstood something</li></ol><h3 id="step-3-create-your-own-test-cases" tabindex="-1">Step 3: Create Your Own Test Cases <a class="header-anchor" href="#step-3-create-your-own-test-cases" aria-label="Permalink to &quot;Step 3: Create Your Own Test Cases&quot;">‚Äã</a></h3><p>Design cases that could break your solution:</p><p><strong>Essential Test Cases:</strong></p><ul><li><strong>Minimum case</strong>: Smallest possible valid input</li><li><strong>Maximum case</strong>: Largest input within constraints</li><li><strong>Edge cases</strong>: Boundary conditions, special values</li><li><strong>Corner cases</strong>: Empty inputs, all same values, negative numbers</li><li><strong>Stress cases</strong>: Random large inputs (if time permits)</li></ul><h3 id="step-4-algorithm-design-on-paper" tabindex="-1">Step 4: Algorithm Design on Paper <a class="header-anchor" href="#step-4-algorithm-design-on-paper" aria-label="Permalink to &quot;Step 4: Algorithm Design on Paper&quot;">‚Äã</a></h3><ol><li><strong>Start with brute force</strong>: How would you solve this if efficiency didn&#39;t matter?</li><li><strong>Analyze the brute force</strong>: Count the operations. Too slow?</li><li><strong>Optimize step by step</strong>: What repeated work can you eliminate?</li><li><strong>Write pseudocode</strong>: High-level steps, not actual code</li></ol><hr><h2 id="phase-3-üîç-strategic-problem-analysis" tabindex="-1">Phase 3: üîç Strategic Problem Analysis <a class="header-anchor" href="#phase-3-üîç-strategic-problem-analysis" aria-label="Permalink to &quot;Phase 3: üîç Strategic Problem Analysis&quot;">‚Äã</a></h2><h3 id="pattern-recognition-checklist" tabindex="-1">Pattern Recognition Checklist <a class="header-anchor" href="#pattern-recognition-checklist" aria-label="Permalink to &quot;Pattern Recognition Checklist&quot;">‚Äã</a></h3><p><strong>Is this a known problem type?</strong></p><ul><li>Sorting/Searching problem?</li><li>Graph traversal (BFS/DFS)?</li><li>Dynamic programming (optimal substructure)?</li><li>Greedy algorithm (local optimal ‚Üí global optimal)?</li><li>Mathematical formula/pattern?</li><li>Data structure problem (stack, queue, priority queue)?</li></ul><p><strong>Problem Transformation Techniques:</strong></p><ul><li>Can I reduce this to a simpler problem?</li><li>Can I solve the reverse/opposite problem?</li><li>Can I solve a smaller version first?</li><li>Are there symmetries I can exploit?</li><li>Can I precompute something to make queries faster?</li></ul><p>If you find yourself stuck, don&#39;t get obssessed with a single idea and try these approaches:</p><ol><li><strong>Simplify</strong>: Solve for n=1, n=2, n=3 and look for patterns</li><li><strong>Visualize</strong>: Draw the problem if possible</li><li><strong>Transform</strong>: Change variables, coordinate systems, or perspective</li></ol><hr><h2 id="phase-4-üìù-systematic-implementation" tabindex="-1">Phase 4: üìù Systematic Implementation <a class="header-anchor" href="#phase-4-üìù-systematic-implementation" aria-label="Permalink to &quot;Phase 4: üìù Systematic Implementation&quot;">‚Äã</a></h2><h3 id="pre-coding-checklist" tabindex="-1">Pre-Coding Checklist <a class="header-anchor" href="#pre-coding-checklist" aria-label="Permalink to &quot;Pre-Coding Checklist&quot;">‚Äã</a></h3><ul><li>I have a clear algorithm written in pseudocode</li><li>I&#39;ve traced through my algorithm on paper</li><li>I know the time and space complexity</li><li>I know which data structures I&#39;ll use</li></ul><h3 id="implementation-strategy" tabindex="-1">Implementation Strategy <a class="header-anchor" href="#implementation-strategy" aria-label="Permalink to &quot;Implementation Strategy&quot;">‚Äã</a></h3><p><strong>1. Template First</strong> Start with input/output scaffolding:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Read input</span></span>
<span class="line"><span>// Process</span></span>
<span class="line"><span>// Output result</span></span></code></pre></div><p><strong>2. Build Incrementally</strong></p><ul><li>Implement one function/section at a time</li><li>Test each piece before moving on</li><li>Use placeholder values to test structure</li></ul><p><strong>3. Defensive Programming</strong></p><ul><li>Use meaningful variable names</li><li>Add comments for complex logic</li><li>Consider integer overflow issues</li></ul><h3 id="common-implementation-pitfalls" tabindex="-1">Common Implementation Pitfalls <a class="header-anchor" href="#common-implementation-pitfalls" aria-label="Permalink to &quot;Common Implementation Pitfalls&quot;">‚Äã</a></h3><ul><li><strong>Off-by-one errors</strong>: Double-check array indices and loop bounds</li><li><strong>Integer overflow</strong>: Use long long if values can exceed 10‚Åπ</li><li><strong>Precision issues</strong>: Use appropriate data types for floating-point</li><li><strong>Case sensitivity</strong>: Match output format exactly</li><li><strong>Trailing spaces/newlines</strong>: Follow format specifications precisely</li></ul><hr><h2 id="phase-5-‚úÖ-rigorous-testing-and-debugging" tabindex="-1">Phase 5: ‚úÖ Rigorous Testing and Debugging <a class="header-anchor" href="#phase-5-‚úÖ-rigorous-testing-and-debugging" aria-label="Permalink to &quot;Phase 5: ‚úÖ Rigorous Testing and Debugging&quot;">‚Äã</a></h2><h3 id="testing-protocol" tabindex="-1">Testing Protocol <a class="header-anchor" href="#testing-protocol" aria-label="Permalink to &quot;Testing Protocol&quot;">‚Äã</a></h3><p><strong>Level 1: Sample Tests</strong></p><ul><li>Run all provided examples</li><li>If any fail, debug immediately‚Äîdon&#39;t proceed</li></ul><p><strong>Level 2: Edge Case Tests</strong></p><ul><li>Test your manually created edge cases</li><li>Pay special attention to boundary values</li></ul><p><strong>Level 3: Stress Testing (if time permits)</strong></p><ul><li>Generate random test cases</li><li>Compare with brute force solution</li><li>Look for patterns in failures</li></ul><h3 id="debugging-methodology" tabindex="-1">Debugging Methodology <a class="header-anchor" href="#debugging-methodology" aria-label="Permalink to &quot;Debugging Methodology&quot;">‚Äã</a></h3><p><strong>When Wrong Answer:</strong></p><ol><li><strong>Re-read the problem</strong>: 50% of wrong answers are misunderstandings</li><li><strong>Check sample cases</strong>: Trace through manually again</li><li><strong>Print intermediate values</strong>: See where logic diverges from expectation</li><li><strong>Simplify the input</strong>: Use smaller cases to isolate the bug</li></ol><p><strong>When Time Limit Exceeded:</strong></p><ol><li><strong>Verify complexity</strong>: Count operations in your algorithm</li><li><strong>Look for infinite loops</strong>: Check loop termination conditions</li><li><strong>Optimize bottlenecks</strong>: Profile which parts are slowest</li><li><strong>Consider algorithm change</strong>: Sometimes you need a fundamentally different approach</li></ol><p><strong>When Runtime Error:</strong></p><ol><li><strong>Array bounds</strong>: Check all array accesses</li><li><strong>Null pointers</strong>: Verify pointer/reference validity</li><li><strong>Stack overflow</strong>: Check recursion depth</li><li><strong>Division by zero</strong>: Verify denominators</li></ol><p>More advice on debugging is available in the <a href="./debugging.html">Debugging Practices</a> guide.</p><hr><h2 id="phase-6-üîÑ-post-solution-reflection" tabindex="-1">Phase 6: üîÑ Post-Solution Reflection <a class="header-anchor" href="#phase-6-üîÑ-post-solution-reflection" aria-label="Permalink to &quot;Phase 6: üîÑ Post-Solution Reflection&quot;">‚Äã</a></h2><h3 id="learning-extraction-process" tabindex="-1">Learning Extraction Process <a class="header-anchor" href="#learning-extraction-process" aria-label="Permalink to &quot;Learning Extraction Process&quot;">‚Äã</a></h3><p><strong>Immediately After Solving:</strong></p><ul><li>What was the key insight that led to the solution?</li><li>Which part took the longest? (reading, thinking, coding, debugging)</li><li>What would I do differently next time?</li></ul><p><strong>After Reading Editorial (if available):</strong></p><ul><li>Was there a simpler solution I missed?</li><li>What techniques did the editorial use that I didn&#39;t know?</li><li>How can I recognize similar problems in the future?</li></ul><h3 id="personal-problem-database" tabindex="-1">Personal Problem Database <a class="header-anchor" href="#personal-problem-database" aria-label="Permalink to &quot;Personal Problem Database&quot;">‚Äã</a></h3><p>Keep a log with:</p><ul><li>Problem name and difficulty</li><li>Key techniques used</li><li>Time spent on each phase</li><li>Mistakes made and lessons learned</li></ul><hr><h2 id="üöÄ-the-mindset-of-champions" tabindex="-1">üöÄ The Mindset of Champions <a class="header-anchor" href="#üöÄ-the-mindset-of-champions" aria-label="Permalink to &quot;üöÄ The Mindset of Champions&quot;">‚Äã</a></h2><p><strong>Remember:</strong> Programming contests reward <strong>systematic thinking</strong> and <strong>careful execution</strong>, not just algorithmic knowledge.</p><p><strong>The 90/10 Principle:</strong> If you spend 90% of your time thinking and planning, the remaining 10% (coding) becomes almost trivial.</p><p><strong>Consistency beats intensity:</strong> Daily practice for 30 minutes is better than weekend marathons.</p><p><strong>Mistakes are data:</strong> Every wrong submission teaches you something about your thought process.</p><p><strong>Patience pays off:</strong> The best problem solvers take their time to understand fully before coding.</p>`,92)])])}const c=t(n,[["render",r]]);export{u as __pageData,c as default};
