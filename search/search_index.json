{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the AOI Study Hub","text":"<p>The Algerian Olympiad in Informatics (AOI) Study Hub is your central resource for:</p> <ul> <li> <p>\ud83d\udcd8 Learning materials and guides  </p> </li> <li> <p>\ud83d\udcdd Editorials for AOI contests  </p> </li> <li> <p>\ud83d\udca1 Problem-solving strategies  </p> </li> <li> <p>\ud83d\udcda Recommended resources for IOI-level preparation  </p> </li> </ul> <p>Our goal is to support students in their journey through competitive programming, from their very first steps to advanced training.</p>"},{"location":"#what-youll-find-here","title":"\ud83d\udd0e What You\u2019ll Find Here","text":"<ul> <li> <p>Study Resources   A curated set of tutorials, handouts, and references covering algorithms, data structures, paradigms, and problem-solving techniques.</p> </li> <li> <p>Contest Editorials   Step-by-step explanations and solutions to AOI contest problems, helping you understand different approaches and improve your skills.</p> </li> <li> <p>Training Materials   Collections of exercises, problems, and practice contests to prepare for national and international olympiads.</p> </li> <li> <p>External Resources   Links to trusted platforms such as France-IOI, DMOJ, and CSES.</p> </li> </ul>"},{"location":"#about-aoi","title":"\ud83c\udf0d About AOI","text":"<p>The Algerian Olympiad in Informatics (AOI) is the national training program for informatics olympiads. Top contestants represent Algeria in the International Olympiad in Informatics (IOI). This site was built to centralize knowledge and make preparation accessible to everyone interested in algorithms, coding, and problem-solving.</p>"},{"location":"#contributing","title":"\ud83d\udcec Contributing","text":"<p>This hub is community-driven! - Found a mistake? - Want to add a resource or write an editorial?  </p> <p>Open a pull request on GitHub or reach out to the AOI team.  </p> <p>Together, let\u2019s grow Algeria\u2019s competitive programming community!</p>"},{"location":"editorials/IOI%20TST%202025/","title":"IOI TST 2025 Editorials","text":"<p>This directory contains editorials for the problems from the IOI TST 2025 contest. This contest served as a selection test to select Algeria's team in the International Olympiad in Informatics (IOI) 2025.</p>"},{"location":"editorials/IOI%20TST%202025/#problems","title":"Problems","text":"<ul> <li>Temperature</li> <li>Turtles</li> <li>Quantum</li> <li>Goal</li> </ul>"},{"location":"editorials/IOI%20TST%202025/#contest-organizers-and-contributors","title":"Contest organizers and contributors","text":"<ul> <li>Raouf Ould Ali</li> <li>Firas Mohammed El Amine Kiram</li> <li>Chams Eddine Abdelali Derreche</li> <li>Raihane Sidhoum</li> <li>Aboubakr Bendahmane</li> <li>Assil Abderezzak Boukhennoufa</li> <li>Mohamed Boukra</li> </ul>"},{"location":"editorials/IOI%20TST%202025/goal/","title":"Goal","text":""},{"location":"editorials/IOI%20TST%202025/goal/#problem-statement","title":"Problem Statement","text":"<ul> <li> <p>English</p> </li> <li> <p>French</p> </li> <li> <p>Arabic</p> </li> </ul>"},{"location":"editorials/IOI%20TST%202025/goal/#solution","title":"Solution","text":"<p>In this problem we have to find the shortest path to get to the final cell.</p> <p>We have an $n \\times m $ grid and we will start in the cell $ (1,1) $ and we want to get into the final cell which is $ (n,m) $.</p> <p>Each cell is one of the following:</p> <p>When you end a row in the grid, you start in the beginning of the next row.</p> <p>Find the shortest path from the point $ (1,1) $ to the point $ (n,m) $ or print $ -1 $ if there is no such path.</p> <p>A general idea before we go to the solution: we can get rid of the grid and make a 1D line.</p>"},{"location":"editorials/IOI%20TST%202025/goal/#subtask-1-15-points","title":"Subtask 1: 15 points","text":"<p>Each cell is either an empty cell or an obstacle.</p> <ul> <li>If there is an obstacle, the answer is \\(-1\\) because we won't be able   to reach the cell $ (n,m) $.</li> <li>Otherwise, the answer is $ n \\times m - 1 $.</li> </ul>"},{"location":"editorials/IOI%20TST%202025/goal/#subtask-2-20-points","title":"Subtask 2: 20 points","text":"<p>Not sure what the intended solution is, but maybe try all ways using DFS (likely TLE).</p>"},{"location":"editorials/IOI%20TST%202025/goal/#subtask-3-25-points","title":"Subtask 3: 25 points","text":"<p>This idea covers subtasks 2 and 3.</p> <p>We can go from the end and solve it using DP:</p> <ul> <li>Empty cell \u2192 move forward by 1 step.</li> <li>Obstacle \u2192 push 2 cells backward.</li> <li>Booster cell  \u2192 jump forward by the digit (if valid), or   move 1 step forward.</li> </ul> <p>If booster goes out of grid, ignore it. Base case: $ dp(n \\times m - 1) = 0 $. Answer: $ dp(0) $. Time complexity: $ O(n \\times m ) $.</p>"},{"location":"editorials/IOI%20TST%202025/goal/#subtask-4-100-points","title":"Subtask 4: 100 points","text":"<p>Run BFS from the start cell.</p> <ul> <li>Check if visited.</li> <li>Maintain number of steps in BFS.</li> <li>Answer is in $ (n,m) $ or $ -1 $ if unreachable.</li> </ul> <p>Time complexity: $ O(n \\times m ) $.</p>"},{"location":"editorials/IOI%20TST%202025/quantum/","title":"Quantum","text":""},{"location":"editorials/IOI%20TST%202025/quantum/#problem-statement","title":"Problem Statement","text":"<ul> <li> <p>English</p> </li> <li> <p>French</p> </li> <li> <p>Arabic</p> </li> </ul>"},{"location":"editorials/IOI%20TST%202025/quantum/#solution","title":"Solution","text":"<p>We have an $n \\times m $ grid, initially empty. We will be given \\(C\\) points. Each time we add a point, we must choose a point \\((x,y)\\) in the grid such that the sum of distances from all added points to \\((x,y)\\) is minimized.</p>"},{"location":"editorials/IOI%20TST%202025/quantum/#subtask-1-5-points","title":"Subtask 1: 5 points","text":"<p>Grid is $ 1 \\times 2 $. Just check whether \\((1,1)\\) or \\((1,2)\\) is better.</p>"},{"location":"editorials/IOI%20TST%202025/quantum/#subtask-2-15-points","title":"Subtask 2: 15 points","text":"<p>Use a 2D array initialized to zeros. For each new point \\((x,y)\\):</p> <ul> <li>Add distance to all cells.</li> <li>Take minimum.</li> </ul> <p>Time complexity: $ O( n \\times m \\times c ) $.</p>"},{"location":"editorials/IOI%20TST%202025/quantum/#subtask-3-30-points","title":"Subtask 3: 30 points","text":"<p>We use a greedy/median idea.</p> <p>For 1D: given $ X_1, X_2, \\dots $, to minimize $ \\sum|X_i - v| $, pick median. So:</p> <ul> <li>Maintain arrays of $ x $'s and $ y $'s separately.</li> <li>Each time, sort them, pick median, compute sum of distances.</li> </ul> <p>Time complexity: $ O( c^2 \\log{c} ) $.</p>"},{"location":"editorials/IOI%20TST%202025/quantum/#subtask-4-100-points","title":"Subtask 4: 100 points","text":"<p>Optimize subtask 3 with data structures:</p> <ul> <li>Ordered set \u2192 find median in $ O( \\log{c} ) $.</li> <li>Lazy segment tree \u2192 range update/query for sums.</li> </ul> <p>Final complexity: $ O(c \\times ( \\log{c} + \\log{n} + \\log{m} )  ) $ .</p>"},{"location":"editorials/IOI%20TST%202025/temperature/","title":"Temperature","text":""},{"location":"editorials/IOI%20TST%202025/temperature/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul>"},{"location":"editorials/IOI%20TST%202025/temperature/#solution","title":"Solution","text":"<p>We have the values of \\(V\\) and we want to compute the values of \\(T\\) as follows:</p> \\[ T_i = \\begin{cases} 0 &amp; \\text{if } i = 0 \\\\ T_{i-1} + V_{i-1} &amp; \\text{if } i \\geq 1 \\end{cases} \\] <p>Once we compute the values of \\(T\\), we want the final answer:</p> <p>$ mx = \\max_{0 \\leq i &lt; j \\leq n} T_j - T_i $</p>"},{"location":"editorials/IOI%20TST%202025/temperature/#subtask-1-2-60-points","title":"Subtask 1 &amp; 2: 60 points","text":"<p>We can use two nested loops and find the maximum among all pairs $ (i, j) $ in the array \\(T\\).</p>"},{"location":"editorials/IOI%20TST%202025/temperature/#subtask-3-100-points","title":"Subtask 3: 100 points","text":"<p>To maximize the answer for any \\(j\\) from 1 to \\(n-1\\), we need to subtract it from the minimum value in the range $ [0, j-1] $. We can maintain this minimum value while iterating.</p> <p>Let: </p> <ul> <li> <p><code>mn</code> = minimum value seen so far (initially $ 1e18 $).</p> </li> <li> <p><code>mx</code> = best answer so far (initially 0)</p> </li> </ul> <p>For each \\(i\\): </p> <ul> <li> <p>$ mn = \\min(mn, T_i) $.</p> </li> <li> <p>$ mx = \\max(mx, T_i - mn) $.</p> </li> </ul> <p>At the end, the answer is in <code>mx</code>.</p> <p>Print <code>mx</code> and congrats, you got 100 points!</p>"},{"location":"editorials/IOI%20TST%202025/turtles/","title":"Turtles","text":""},{"location":"editorials/IOI%20TST%202025/turtles/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul>"},{"location":"editorials/IOI%20TST%202025/turtles/#solution","title":"Solution","text":"<p>We have two arrays and we want to make them equal with the minimum number of operations. Operation: change current number to its greatest proper divisor (largest divisor smaller than it).</p>"},{"location":"editorials/IOI%20TST%202025/turtles/#subtask-1-8-points","title":"Subtask 1: 8 points","text":"<p>Brute force all possible arrays, check minimum operations.</p>"},{"location":"editorials/IOI%20TST%202025/turtles/#subtask-2-12-points","title":"Subtask 2: 12 points","text":"<p>All numbers are prime or \\(1\\). - Greatest proper divisor of a prime is \\(1\\). - Count occurrences of each prime in both arrays. - Answer = sum of absolute differences.</p> <p>Example:</p> <ul> <li> <p>$ A $ = <code>1 1 2 3 5 5</code></p> </li> <li> <p>$ B $ = <code>1 2 2 5 7 11</code></p> </li> <li> <p>Answer = $ | occA[p] - occB[p]| $ summed over primes.</p> </li> </ul>"},{"location":"editorials/IOI%20TST%202025/turtles/#subtask-3-10-points","title":"Subtask 3: 10 points","text":"<p>All numbers are powers of two.</p> <ul> <li> <p>Sort both arrays.</p> </li> <li> <p>For each \\(i\\), divide larger of \\(A_i, B_i\\) until it matches smaller, counting steps.</p> </li> <li> <p>GPD of power of two is always half.</p> </li> </ul>"},{"location":"editorials/IOI%20TST%202025/turtles/#subtask-5-100-points","title":"Subtask 5: 100 points","text":"<p>(Skipping subtask 4).</p> <p>Greedy approach:  - Need fast GPD calculation \u2192 precompute with sieve.</p> <ul> <li> <p>Use priority queues for A and B.</p> </li> <li> <p>While not empty:</p> </li> <li> <p>Compare max of both.</p> </li> <li> <p>If equal \u2192 pop both.</p> </li> <li> <p>Else \u2192 replace larger with its GPD, increment ops.</p> </li> </ul> <p>Time complexity: $ O(C \\log{C} ) $, where $ C \\leq 10^6 $.</p>"},{"location":"editorials/Implementation%20Gauntlets/chaos/","title":"1.The Trial of Order and Chaos","text":""},{"location":"editorials/Implementation%20Gauntlets/chaos/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul>"},{"location":"editorials/Implementation%20Gauntlets/chaos/#solution","title":"Solution","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\ntypedef long long ll;\ntypedef __int128 int128;\n\nint main() {\n    int n, m; \n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;ll&gt; a(n);\n    for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i];\n\n    // --- Ritual 1 ---\n    vector&lt;int&gt; pre(n), alt_pre(n);\n    for (int i = 0; i &lt; n; ++i) {\n        ll curr = 0;\n        if (i % 2 == 0) for (int j = 0; j &lt;= i; j++) curr += a[j];\n        else {\n            int sign = 1;\n            for (int j = i; j &gt;= 0; --j) {\n                curr += sign * a[j];\n                sign *= -1;\n            }\n        }\n        if (i % 2) alt_pre[i] = ((curr % m) + m) % m;\n        else pre[i] = curr % m;\n    }\n\n    for (int i = 0; i &lt; n; ++i) {\n        if (i % 2) a[i] = alt_pre[i];\n        else a[i] = pre[i];\n        cout &lt;&lt; a[i] &lt;&lt; \" \";\n    }\n    cout &lt;&lt; \"\\n\";\n\n    // --- Ritual 2 ---\n    vector&lt;ll&gt; b;\n    for (int i = 0; i &lt; n - 2; ++i) {\n        for (int j = i + 1; j &lt; n - 1; ++j) {\n            for (int k = j + 1; k &lt; n; ++k) {\n                ll val = (a[i] + a[j] + a[k]) % m;\n                if (val % 2 == 0) b.push_back(val);\n                else {\n                    int128 sq = 1LL * val * val;\n                    sq %= m;\n                    b.push_back((ll)sq);\n                }\n            }\n        }\n    }\n\n    for (ll x: b) cout &lt;&lt; x &lt;&lt; \" \";\n    cout &lt;&lt; \"\\n\";\n\n    // --- Ritual 3 ---\n    sort(b.begin(), b.end());\n    for (int i = 0; i * 3 &lt; (int)b.size(); i++) {\n        if (i % 2 == 1) reverse(b.begin() + i * 3, b.begin() + min((int)b.size(), i * 3 + 3));\n    }\n\n    for (ll x: b) cout &lt;&lt; x &lt;&lt; \" \";\n    cout &lt;&lt; \"\\n\";\n\n    // --- Ritual 4 ---\n    sort(b.begin(), b.end());\n    b.erase(unique(b.begin(), b.end()), b.end());\n\n    vector&lt;ll&gt; add;\n    set&lt;ll&gt; B(b.begin(), b.end());\n    for (int t = 0; t &lt; m; t++) {\n        if (B.count(t) == 0 &amp;&amp; B.count(t + 1) == 1) add.push_back(t);\n    }\n    for (ll x: add) b.push_back(x);\n\n    sort(b.begin(), b.end());\n    b.erase(unique(b.begin(), b.end()), b.end());\n\n    for (ll x: b) cout &lt;&lt; x &lt;&lt; \" \";\n    cout &lt;&lt; \"\\n\";\n\n    // --- Ritual 5 ---\n    vector&lt;ll&gt; c;\n    for (ll x: b) {\n        if (x % 3 == 0) c.push_back((x / 3) % m);\n        else if (x % 3 == 1) c.push_back((x * 2 + 1) % m);\n        else c.push_back(((x * x - 1) % m + m) % m);\n    }\n\n    for (ll x: c) if (x % 2 == 0) cout &lt;&lt; x &lt;&lt; \" \";\n    for (ll x: c) if (x % 2 == 1) cout &lt;&lt; x &lt;&lt; \" \";\n    cout &lt;&lt; \"\\n\";\n\n\n    return 0;\n}\n</code></pre>"},{"location":"editorials/PAIO%20TST%202025/","title":"PAIO TST 2025 Editorials","text":"<p>This directory contains editorials for the problems from the PAIO TST 2025 contest. This contest served as a selection test to select Algeria's team in the Pan-African Informatics Olympiad (PAIO) 2025.</p>"},{"location":"editorials/PAIO%20TST%202025/#problems","title":"Problems","text":"<ul> <li>Alpacas</li> <li>Carnival</li> <li>Cooling</li> <li>Garden</li> <li>Gift</li> <li>Nelward</li> <li>Plane</li> <li>Purchase</li> </ul>"},{"location":"editorials/PAIO%20TST%202025/#contest-organizers-and-contributors","title":"Contest organizers and contributors","text":"<ul> <li>Raouf Ould Ali</li> <li>Elyas Sahnoune</li> <li>Said Kebir</li> <li>Mohammed Hachem Drici</li> <li>Chams Eddine Abdelali Derreche</li> <li>Fatima Zahra Kihel</li> <li>Thamella Belaidi</li> <li>Hiba Hamidi</li> <li>Wissal Mechri</li> <li>Yousef Jaeda</li> <li>Yassir Salama</li> </ul>"},{"location":"editorials/PAIO%20TST%202025/alpacas/","title":"Alpacas","text":"<p>Written by Omar Abdelkafi Ykrelef.</p>"},{"location":"editorials/PAIO%20TST%202025/alpacas/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul>"},{"location":"editorials/PAIO%20TST%202025/alpacas/#solution","title":"Solution","text":"<p>The problem naturally divides into two parts: minimum moves and maximum moves.</p>"},{"location":"editorials/PAIO%20TST%202025/alpacas/#minimum-number-of-moves","title":"Minimum number of moves","text":"<p>We want all alpacas to fit inside a consecutive block of length \\(n\\). If a block already contains \\(k\\) alpacas, then the number of moves needed is:</p> \\[ \\text{moves} = n - k \\] <p>So we need to maximize \\(k\\).</p>"},{"location":"editorials/PAIO%20TST%202025/alpacas/#key-idea","title":"Key idea","text":"<p>Each alpaca can act as a boundary of the block:</p> <ul> <li>If \\(A[i]\\) is the left endpoint, the block is:</li> </ul> \\[ [L, R] = [A[i], \\; A[i] + n - 1] \\] <ul> <li>If \\(A[i]\\) is the right endpoint, the block is:</li> </ul> \\[ [L, R] = [A[i] - n + 1, \\; A[i]] \\]"},{"location":"editorials/PAIO%20TST%202025/alpacas/#algorithm","title":"Algorithm","text":"<p>Step 1: Sorting</p> <p>First, sort the alpaca positions:</p> \\[ a = \\text{sorted positions} \\] <p>Now \\(a\\) is in increasing order. This makes it possible to use binary search.</p> <p>Step 2: Binary search</p> <p>To count how many alpacas lie inside \\([L, R]\\):</p> <ul> <li> <p><code>lower_bound(a.begin(), a.end(), L)</code>   \u2192 gives the first index \\(\\text{idx}_L\\) where \\(a[\\text{idx}_L] \\geq L\\).</p> </li> <li> <p><code>upper_bound(a.begin(), a.end(), R)</code>   \u2192 gives the first index after the last alpaca \\(\\leq R\\).   \u2192 subtract 1 to get the last index \\(\\text{idx}_R\\) where \\(a[\\text{idx}_R] \\leq R\\).</p> </li> </ul> <p>Now the alpacas inside \\([L, R]\\) are exactly from \\(a[\\text{idx}_L]\\) to \\(a[\\text{idx}_R]\\).</p> <p>So the count is:</p> \\[ \\text{count} = \\text{idx}_R - \\text{idx}_L + 1 \\] <p>Step 3: Applying it to our problem</p> <p>For each alpaca \\(a[i]\\), we consider two ranges:</p> <ol> <li>Treat \\(a[i]\\) as the left endpoint:</li> </ol> \\[ L = a[i], \\quad R = a[i] + n - 1 \\] <p>Count how many alpacas are inside \\([L, R]\\).</p> <ol> <li>Treat \\(a[i]\\) as the right endpoint:</li> </ol> \\[ L = a[i] - n + 1, \\quad R = a[i] \\] <p>Count how many alpacas are inside \\([L, R]\\).</p> <p>We do this with binary search for each alpaca, and keep the maximum count.</p> <p>Finally:</p> \\[ \\text{minimum moves} = n - \\max(\\text{count}) \\]"},{"location":"editorials/PAIO%20TST%202025/alpacas/#special-case","title":"Special case","text":"<p>If the formula gives <code>1</code> and the single empty position is at one end (either before the first alpaca or after the last alpaca), then the answer should be <code>2</code> (since you cannot solve it in a single move).</p>"},{"location":"editorials/PAIO%20TST%202025/alpacas/#maximum-number-of-moves","title":"Maximum number of moves","text":"<p>At first glance, you might think to count all free spots. However, alpacas cannot be moved all the way to the extreme ends.</p> <p>Define:</p> \\[ \\text{total\\_free} = (A[n] - A[1] + 1) - n \\] <p>(all empty spots between the first and last alpaca).</p> \\[ \\text{first\\_gap} = A[2] - A[1] - 1 \\] \\[ \\text{last\\_gap} = A[n] - A[n-1] - 1 \\] <p>Then the maximum number of moves is:</p> \\[ \\max(\\text{total\\_free} - \\text{first\\_gap}, \\; \\text{total\\_free} - \\text{last\\_gap}) \\]"},{"location":"editorials/PAIO%20TST%202025/alpacas/#time-complexity","title":"Time complexity","text":"<ul> <li>Finding minimum moves: \\(O(n \\log n)\\)</li> <li>Finding maximum moves: \\(O(1)\\)</li> </ul> <p>Total time complexity:</p> \\[ O(n \\log n) \\]"},{"location":"editorials/PAIO%20TST%202025/alpacas/#implementation","title":"Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; a(n+1);\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; a[i];\n    }\n    sort(a.begin(), a.end()); // sort alpaca positions\n\n    int MIN = INT_MAX;\n\n    // Try each alpaca as both left and right endpoint\n    for (int i = 1; i &lt;= n; i++) {\n        int down = a[i] - n + 1; // block of length n ending at a[i]\n        int up   = a[i] + n - 1; // block of length n starting at a[i]\n\n        // d1 = index of first alpaca &gt;= down\n        int d1 = distance(a.begin(), lower_bound(a.begin(), a.end(), down));\n        // d2 = index of last alpaca &lt;= up\n        int d2 = distance(a.begin(), upper_bound(a.begin(), a.end(), up)) - 1;\n\n        // number of alpacas covered if we use \"down\" block\n        int ans1 = n - (abs(i - d1) + 1);\n        // number of alpacas covered if we use \"up\" block\n        int ans2 = n - (abs(i - d2) + 1);\n\n        // special case: if result = 1 and the empty spot is at the side \u2192 needs 2\n        if (a[d1] != down &amp;&amp; ans1 == 1) {\n            ans1++;\n        }\n        if (a[d2] != up &amp;&amp; ans2 == 1) {\n            ans2++;\n        }\n\n        MIN = min(MIN, min(ans1, ans2));\n    }\n    int sum = (a[n] - a[1] + 1) - n; // total free spaces\n\n    // maximum moves = max(total_free - first_gap, total_free - last_gap)\n    int MAX = max(sum - (a[n] - a[n - 1] - 1) , sum - (a[2] - a[1] - 1));\n\n    cout &lt;&lt; MIN &lt;&lt; '\\n' &lt;&lt; MAX &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"editorials/PAIO%20TST%202025/carnival/","title":"Carnival","text":"<p>Written by Raouf Ould Ali.</p>"},{"location":"editorials/PAIO%20TST%202025/carnival/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul> <p>We are given \\(N\\) lattice points (\\(3 \\leq N &lt; 100\\)), with the guarantee that no three points are collinear. For every triple of points \\((A, B, C)\\), these form a triangle. The score of this triangle is the number of points lying strictly inside it (excluding its vertices). The task is to output, for each possible score \\(i\\), how many triangles contain exactly \\(i\\) points.</p>"},{"location":"editorials/PAIO%20TST%202025/carnival/#key-observations","title":"Key Observations","text":"<ul> <li> <p>Na\u00efve approach    For each triangle \\((A, B, C)\\), check every other point to see if it lies inside.</p> <ul> <li>This is \\(O(N^4)\\): there are \\(O(N^3)\\) triangles, and each check costs \\(O(N)\\).</li> <li>With \\(N &lt; 100\\), this is too slow.</li> </ul> </li> <li> <p>Sorting helps    The first step in the solution is to sort the points by their \\((x, y)\\)-coordinates.</p> <ul> <li>After sorting, any triangle \\((i, j, k)\\) with \\(i &lt; j &lt; k\\) will have its vertices ordered with respect to the \\(x\\) component.</li> <li>This prevents double-counting and ensures that the <code>points_below[i][j]</code> values behave consistently when we combine them.</li> </ul> </li> </ul>"},{"location":"editorials/PAIO%20TST%202025/carnival/#precomputation-points-under-a-segment","title":"Precomputation: Points under a segment","text":"<p>For two points \\(A_i\\) and \\(A_j\\) (\\(i &lt; j\\)), consider the directed segment \\((A_i \\to A_j)\\). We count how many points with indices strictly between \\(i\\) and \\(j\\) lie strictly to the right of this line.</p> <p>Formally:</p> \\[ points\\_ below[i][j] = \\#\\{ k : i &lt; k &lt; j, \\; \\text{cross}(A_j - A_i, A_k - A_i) &lt; 0 \\} \\] <p>This preprocessing costs \\(O(N^3)\\).</p>"},{"location":"editorials/PAIO%20TST%202025/carnival/#using-the-precomputation-for-triangles","title":"Using the precomputation for triangles","text":"<p>Now, for each triple \\((i,j,k)\\) with \\(i&lt;j&lt;k\\), we want to compute the number of points inside the triangle \\((A_i,A_j,A_k)\\).</p> <ul> <li>If the orientation \\((i,j,k)\\) is counter-clockwise:</li> </ul> <p>$$   \\text{inside} = points\\_below[i][k] - points\\_below[i][j] - points\\_below[j][k] - 1   $$</p> <ul> <li>If the orientation is clockwise:</li> </ul> <p>$$   \\text{inside} = points\\_below[i][j] + points\\_below[j][k] - points\\_below[i][k]   $$</p> <p>We then increment the counter:</p> \\[ O[\\text{inside}] += 1 \\]"},{"location":"editorials/PAIO%20TST%202025/carnival/#complexity-analysis","title":"Complexity Analysis","text":"<ul> <li>Sorting: \\(O(N \\log N)\\)</li> <li>Precomputation: \\(O(N^3)\\) for filling <code>points_below</code></li> <li>Triangle enumeration: \\(O(N^3)\\)</li> <li>Total: \\(O(N^3)\\), which is efficient for \\(N \\leq 100\\).</li> </ul> <p>Memory: \\(O(N^2)\\) for <code>points_below</code>.</p>"},{"location":"editorials/PAIO%20TST%202025/carnival/#implementation","title":"Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n#define int long long\nusing namespace std;\n\nint cross_product(int x1, int y1, int x2, int y2)\n{\n    return x1 * y2 - x2 * y1;\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;pair&lt;int, int&gt;&gt; point(n);\n    for (int i = 0; i &lt; n; i++)\n        cin &gt;&gt; point[i].first &gt;&gt; point[i].second;\n\n    sort(point.begin(), point.end());\n\n    vector&lt;vector&lt;int&gt;&gt; points_below(n, vector&lt;int&gt;(n, 0));\n\n    for (int i = 0; i &lt; n; i++)\n        for (int j = i + 1; j &lt; n; j++)\n        {\n            for (int k = i + 1; k &lt; j; k++)\n            {\n                if (cross_product(point[j].first - point[i].first,\n                                  point[j].second - point[i].second,\n                                  point[k].first - point[i].first,\n                                  point[k].second - point[i].second) &lt; 0)\n                {\n                    points_below[i][j] += 1;\n                }\n            }\n        }\n\n    vector&lt;int&gt; O(n - 2, 0);\n\n    for (int i = 0; i &lt; n; i++)\n        for (int j = i + 1; j &lt; n; j++)\n            for (int k = j + 1; k &lt; n; k++)\n            {\n                if (cross_product(point[j].first - point[i].first,\n                                  point[j].second - point[i].second,\n                                  point[k].first - point[i].first,\n                                  point[k].second - point[i].second) &gt; 0)\n                {\n                    O[points_below[i][k] - points_below[i][j] - points_below[j][k] - 1] += 1;\n                }\n                else\n                {\n                    O[points_below[i][j] + points_below[j][k] - points_below[i][k]] += 1;\n                }\n            }\n\n    for (int i = 0; i &lt; n - 2; i++)\n        cout &lt;&lt; O[i] &lt;&lt; ' ';\n}\n</code></pre>"},{"location":"editorials/PAIO%20TST%202025/cooling/","title":"Cooling","text":"<p>Written by Iyed Baassou.</p>"},{"location":"editorials/PAIO%20TST%202025/cooling/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul>"},{"location":"editorials/PAIO%20TST%202025/cooling/#solution","title":"Solution","text":"<p>We can notice the low constraints of both \\(n\\) (\\(1 \\le n \\le 20\\)) and \\(m\\) (\\(1 \\le m \\le 10\\)) which guides us to using a bruteforce approach. The bruteforce in this problem is finding all unique subsets of coolers and testing if they satisfy the conditions of the problem.</p>"},{"location":"editorials/PAIO%20TST%202025/cooling/#method-used","title":"Method used","text":"<p>In order to find all subsets we can use a recursive or iterative approach, we will cover both of them in this editorial.</p>"},{"location":"editorials/PAIO%20TST%202025/cooling/#recursive-approach","title":"Recursive approach:","text":"<p>We start at the first cooler and do the following: - We use a <code>line</code> array to store the number of units that power each cell. - At each cooler we can either:     - Exclude it and move to the next cooler.     - Include it, add its cost and cooling range to the line, and move to the next cooler         - Note: Remember to backtrack (remove the cooling range) after the recursion call. - When we find a subset, we need to check if the coolers cover all sections with enough units, we iterate over the intervals of each section and check if the power at each point in the interval is equal or greater than \\(C[i]\\) (\\(C[i]\\) is the units needed to cool the section \\(i\\)). <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint n, m;\nvector&lt;vector&lt;int&gt;&gt; sections, coolers;\nint mn = INT_MAX;\n\nvector&lt;int&gt; line(101, 0);\n\nvoid solve(int i, int cost) {\n    if (i == m) {\n        for (auto s: sections) {\n            for (int j = s[0]; j &lt;= s[1]; j++) {\n                if (line[j] &lt; s[2]) return;\n            }\n        }\n        mn = min(mn, cost);\n        return;\n    }\n\n    // Exclude\n    solve(i + 1, cost);\n\n    // Include\n    for (int j = coolers[i][0]; j &lt;= coolers[i][1]; j++) {\n        line[j] += coolers[i][2];\n    }\n    solve(i + 1, cost + coolers[i][3]);\n    for (int j = coolers[i][0]; j &lt;= coolers[i][1]; j++) {\n        line[j] -= coolers[i][2];\n    }\n}\n\nint main() {\n    cin &gt;&gt; n &gt;&gt; m;\n    sections.assign(n, vector&lt;int&gt;(3));\n    for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; 3; j++) cin &gt;&gt; sections[i][j];\n\n    coolers.assign(m, vector&lt;int&gt;(4));\n    for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; 4; j++) cin &gt;&gt; coolers[i][j];\n\n    solve(0, 0);\n    cout &lt;&lt; mn &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre></p> <ul> <li>Time complexity analysis:<ul> <li>Recursion: The number of subsets of an array of length m is \\(2^m\\), our recursive function finds all these subsets causing a time complexity of \\(O(2^m)\\), because at each of the \\(m\\) coolers, we call the recursion twice.</li> <li>Validation:<ul> <li>At each recursion call we add the cooling ranges to the <code>line</code> array, which is \\(O(100)\\) worst-case.</li> <li>When we find a subset and get the <code>line</code> array, we check if all sections are covered with enough units by iterating over all \\(n\\) sections and iterating over their intervals, resulting in a time complexity of \\(O(100 \\cdot n)\\).</li> </ul> </li> </ul> </li> </ul> <p>Overall time complexity: \\(O(2^m \\cdot 100 \\cdot n)\\) which is feasible under problem constraints.</p> <p>Fun fact: you can test if your code TLEs by finding time complexity and replacing the values with the upperbounds of constraints: \\(2^m \\cdot 100 \\cdot n = 2^{10} \\cdot 100 \\cdot 20 = 2048000 \\le 4 \\cdot 10^8\\) It works! \u2705</p>"},{"location":"editorials/PAIO%20TST%202025/cooling/#iterative-approach","title":"Iterative approach:","text":"<p>Instead of recursion, we can iterate over all subsets of coolers using bitmasking.</p> <ul> <li>Each cooler can either be included or not, so we represent a subset of coolers with a bitmask of length <code>m</code> by denoting excluded as a non-set 0-bit and included as a set 1-bit.</li> <li>Similar to the recursive approach, for each subset:<ul> <li>Reset a <code>line</code> array (size <code>100</code>, since positions are bounded) to 0.</li> <li>Add cooling power of the included coolers to their ranges.</li> <li>Sum up the cost of included coolers.</li> <li>Check if all sections are satisfied.</li> </ul> </li> <li>Keep track of the minimum cost across all valid subsets. <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;  \n\nint main() {\n    int n, m; cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;vector&lt;int&gt;&gt; sections(n, vector&lt;int&gt;(3));\n    for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; 3; ++j) cin &gt;&gt; sections[i][j];  \n\n    vector&lt;vector&lt;int&gt;&gt; coolers(m, vector&lt;int&gt;(4));\n    for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; 4; ++j) cin &gt;&gt; coolers[i][j];\n\n    int mn = INT_MAX;\n    for (int mask = 0; mask &lt; (1 &lt;&lt; m); ++mask) {\n        vector&lt;int&gt; line(101, 0);\n\n        int curr = 0;\n\n        for (int i = 0; i &lt; m; ++i) {\n            if (mask &amp; (1 &lt;&lt; i)) {\n                curr += coolers[i][3];\n                for (int j = coolers[i][0]; j &lt;= coolers[i][1]; ++j) {\n                    line[j] += coolers[i][2];\n                }\n            }\n        }\n\n        bool ok = 1;\n        for (int i = 0; i &lt; n; ++i) {\n            for (int j = sections[i][0]; j &lt;= sections[i][1]; ++j) {\n                if (line[j] &lt; sections[i][2]) ok = false;\n            }\n        }\n\n        if (ok) mn = min(mn, curr);\n    }\n\n    cout &lt;&lt; mn;\n    return 0;\n}\n</code></pre></li> <li> <p>Time complexity analysis:</p> <ul> <li> <p>Subsets: There are \\(2^m\\) subsets of coolers.</p> </li> <li> <p>Processing a subset:</p> <ul> <li>Adding chosen coolers\u2019 power to <code>line</code>: each cooler can cover at most <code>100</code> positions. In worst case, all <code>m</code> coolers are included, so cost is \\(O(100 \\cdot m)\\).</li> <li>Checking all <code>n</code> sections: each section covers at most <code>100</code> positions, so validation is \\(O(100 \\cdot n)\\).</li> </ul> </li> </ul> </li> </ul> <p>Overall time complexity: \\(O(2^m\\cdot 100\\cdot (m+n))\\)</p> <ul> <li>If \\(m = 10\\) and \\(n = 20\\): \\(2^{10}\\cdot 100 \\cdot (10+30)=1024*3000=3.072 \\cdot 10^6 \\le 4 \\cdot 10^8\\) \u2705 Feasible within time limits.</li> </ul>"},{"location":"editorials/PAIO%20TST%202025/garden/","title":"Garden","text":"<p>Written by Kian Abolghasemi.</p>"},{"location":"editorials/PAIO%20TST%202025/garden/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul>"},{"location":"editorials/PAIO%20TST%202025/garden/#full-solution","title":"Full Solution","text":"<p>The first thing one should notice is that after we trim the branches, all the leaves would be left at a distance</p> \\[ d &lt; \\max_{i=0}^{n-1} \\mathrm{dist}(0,i) &lt; n . \\] <p>So if we find a way to calculate the minimum number of operations it takes to trim the tree to a length \\(i\\) for all \\(0&lt;i \\leq \\max_{i=0}^{n-1} \\mathrm{dist}(0,i)\\), then we can pick the minimum of all the minima. </p> <p>Notice that to trim a tree to a length \\(d\\), it is clear we must remove any nodes with distances from the root more than \\(d\\). After doing so, there will be \"branches\" whose leaves are less than \\(d\\) away from the roots. We should clearly remove those too, so any node that doesn't have a leaf of distance at least \\(d\\) from the root in their subtree should be removed as well. </p> <p>These must be removed for the condition \"All leaves are of length \\(d\\)\" to be satisfied, so the minimum is at least the number of leaves we have to remove mentioned above. Now removing those is sufficient, because for every node now, it has a subtree that has a leaf of distance at least \\(d\\) from the root, and since we remove all nodes of distance more than \\(d\\), then it has a leaf of distance \\(d\\), so all the leaves are of distance \\(d\\).</p> <p>Thus, for a distance \\(i\\), the number of leaves we should remove is:</p> <ul> <li>the number of leaves of distance more than \\(i\\), plus</li> <li>the number of leaves whose maximum subtree leaf distance from the root is less than \\(i\\).</li> </ul> <p>We can first use a DFS search to get the distance from \\(0\\) for all the nodes, then we could keep a frequency array for how many nodes are of distance \\(i\\) for all \\(i\\), from which we could build a prefix array to get the number of nodes of distance more than \\(i\\).</p> <p>We then make a vector of leaves (the nodes with degree 1, which we can calculate from the input) and sort them from furthest to closest to the root. For each leaf in this vector, we keep assigning their distance as the maximum subtree leaf distance to their parents, until we meet a node with a higher maximum subtree leaf distance. Thus we have for each node the maximum subtree leaf distance, which we could again store in a frequency array, then a prefix sum array to get the number of nodes with maximum subtree leaf distance less than \\(i\\). </p> <p>Therefore, for any \\(i\\), the minimum number of operations can be found in \\(O(1)\\) with \\(O(n \\log n)\\) precomputation. Hence the overall algorithm is \\(O(n \\log n)\\).</p>"},{"location":"editorials/PAIO%20TST%202025/garden/#implementation","title":"Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nvector&lt;long long&gt; dist;\nvector&lt;vector&lt;long long&gt;&gt; edge;\n\n// DFS to get distances\nvoid dfs(long long node, long long prev)\n{\n    for (auto child : edge[node])\n    {\n        if (child == prev)\n            continue;\n        dist[child] = dist[node] + 1;\n        dfs(child, node);\n    }\n}\n\nint main()\n{\n    long long n;\n    cin &gt;&gt; n;\n    vector&lt;long long&gt; deg, mxd, par;\n    deg.assign(n, 0);\n    dist.assign(n, 0);\n    mxd.assign(n, 0);\n    par.assign(n, 0);\n    cin &gt;&gt; par[0];\n    for (long long i = 1; i &lt; n; i++)\n    {\n        cin &gt;&gt; par[i];\n        deg[i]++;\n        deg[par[i]]++;\n    }\n    edge.assign(n, {});\n    for (long long i = 1; i &lt; n; i++)\n    {\n        edge[i].push_back(par[i]);\n        edge[par[i]].push_back(i);\n    }\n    dfs(0, -1);\n    vector&lt;pair&lt;long long, long long&gt;&gt; leaf;\n    for (long long i = 1; i &lt; n; i++)\n        if (deg[i] == 1)\n            leaf.push_back({dist[i], i});\n    sort(leaf.begin(), leaf.end());\n    reverse(leaf.begin(), leaf.end());\n    for (long long i = 0; i &lt; leaf.size(); i++)\n    {\n        long long ind = leaf[i].second;\n        while (mxd[ind] &lt; leaf[i].first)\n        {\n            mxd[ind] = leaf[i].first;\n            ind = par[ind];\n            if (ind == -1)\n                break;\n        }\n    }\n    long long ans = n + 1;\n    vector&lt;long long&gt; cmxd, cd;\n    cmxd.assign(n + 1, 0);\n    cd.assign(n + 1, 0);\n    for (long long i = 0; i &lt; n + 1; i++)\n        cd[i] = 0, cmxd[i] = 0;\n    for (long long i = 0; i &lt; n; i++)\n    {\n        cmxd[mxd[i]]++;\n        cd[dist[i]]++;\n    }\n    vector&lt;long long&gt; premxd, pred;\n    premxd.assign(n + 2, 0);\n    pred.assign(n + 2, 0);\n    for (long long i = 1; i &lt; n + 2; i++)\n    {\n        premxd[i] = premxd[i - 1] + cmxd[i - 1];\n        pred[i] = pred[i - 1] + cd[i - 1];\n    }\n    for (long long i = 1; i &lt;= n; i++)\n    {\n        ans = min(ans, premxd[i] + n - pred[i + 1]);\n    }\n    cout &lt;&lt; ans;\n}\n</code></pre>"},{"location":"editorials/PAIO%20TST%202025/garden/#subtasks","title":"Subtasks","text":"<ul> <li> <p>Subtask 1:   We check for the distance of all leaves. If they are not all equal, the answer is greater than 0, thus it is 1. Otherwise, the answer is 0. Complexity: \\(O(n)\\)</p> </li> <li> <p>Subtask 2:   The condition implies that the only node that has a degree more than 2 is 0, and for all other nodes they are just in one of the straight paths that start from 0 and end at the only leaf in that path. Thus, for any distance \\(i\\), to trim the tree to \\(i\\) is to reduce every path longer than \\(i\\) to \\(i\\), and every path less than \\(i\\) to 0.   We can iterate for each \\(i\\) from 1 to \\(n\\), calculating each time the number of operations we need by going over all the distinct paths and reducing them by the amount needed and increasing a counter by the reduction amount. Taking the minimum of all the final counters from 1 to \\(n\\) gives the answer. Complexity: \\(O(n^2)\\)</p> </li> <li> <p>Subtask 3:   The same condition holds, but our algorithm must be optimized since \\(n\\) is no longer small enough. The optimization is: for every path, take the distance of the leaf and insert all these leaves into a vector, sorted by distance.   Now trimming to a distance \\(i\\) not equal to the original distance of any leaf is futile, since we could do fewer operations by trimming to the distance of the leaf with least distance more than \\(i\\). So we iterate for each leaf, from smallest to largest, and notice that the number of nodes left is the distance of the leaf we chose times the number of leaves with distance larger than its own.   So the number of operations is  </p> </li> </ul> <p>$$   n - (n-i) \\cdot \\mathrm{dist}(0,\\text{leaf}_i).   $$</p> <p>We take the minimum of all the values as the answer. Complexity: \\(O(n \\log n)\\)</p> <ul> <li>Subtask 4:   Since the number of leaves is less than 10, we can brute force. Each time, choose a leaf, and let the goal distance be its distance from the root. For every other leaf, keep trimming until it either is no longer a leaf, or its distance equals that of the chosen leaf. Keeping an operations counter, we choose the minimum value. Complexity: \\(O(n)\\)</li> </ul>"},{"location":"editorials/PAIO%20TST%202025/gift/","title":"Gift","text":"<p>Written by Raouf Ould Ali.</p>"},{"location":"editorials/PAIO%20TST%202025/gift/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul> <p>We are given an array $A$ of size \\(N\\) and an integer $K$. We start with $B = [0,0,\\dots,0]$ and want to transform it into $A$ using operations of the form:</p> <ul> <li>Choose any integer $X &gt; 0$</li> <li>Choose exactly $K$ distinct positions $P_1, P_2, \\dots, P_K$</li> <li>Add $X$ to all $B[P_j]$</li> </ul> <p>The task is to either produce a valid sequence of operations with $M \\cdot K \\leq 3 \\cdot 10^6$, or decide that it is impossible.</p>"},{"location":"editorials/PAIO%20TST%202025/gift/#step-1-feasibility-conditions","title":"Step 1: Feasibility Conditions","text":"<p>Each operation increases the total sum of $B$ by $X \\cdot K$.</p> <ul> <li>Thus,</li> </ul> <p>$$   \\text{sum} = \\sum_{i=1}^N A[i]   $$</p> <p>must be divisible by $K$.</p> <ul> <li>Let</li> </ul> <p>$$   \\text{lim} = \\frac{\\text{sum}}{K}   $$</p> <p>be the required \u201cheight\u201d of each group.</p> <ul> <li>If $\\max(A[i]) &gt; \\text{lim}$, then one element cannot fit into a single group, so the answer is impossible.</li> </ul> <p>So feasibility requires:</p> \\[ \\text{sum} \\bmod K = 0 \\quad \\text{and} \\quad \\max(A[i]) \\leq \\frac{\\text{sum}}{K}. \\]"},{"location":"editorials/PAIO%20TST%202025/gift/#step-2-grid-interpretation","title":"Step 2: Grid Interpretation","text":"<p>Visualize a grid of size $\\text{lim} \\times K$:</p> <ul> <li>The grid has height $\\text{lim}$ and width $K$.</li> <li>Each column corresponds to one bundle of size $\\text{lim}$.</li> <li> <p>We place each $A[i]$ vertically:</p> </li> <li> <p>If it fits in the current column, it stays there.</p> </li> <li>If it overflows, it continues at the top of the next column.</li> </ul> <p>Since $A[i] \\leq \\text{lim}$ for all $i$, a box never skips a column. At most it is split into two consecutive columns.</p>"},{"location":"editorials/PAIO%20TST%202025/gift/#step-3-sweeping-for-operations","title":"Step 3: Sweeping for Operations","text":"<p>Instead of outputting one operation per row (which could be up to $\\text{lim}$ rows), we notice that:</p> <ul> <li>Each column contains one index at a time.</li> <li>The index for a column only changes when one $A[i]$ ends and another begins.</li> </ul> <p>Thus, while sweeping from bottom to top:</p> <ul> <li>We keep track of the current set of active indices for all $K$ columns.</li> <li>We only output an operation when this set changes.</li> <li>The operation covers all rows since the last change, so its increment is the height difference $\\Delta h$.</li> </ul>"},{"location":"editorials/PAIO%20TST%202025/gift/#step-4-bound-on-operations","title":"Step 4: Bound on Operations","text":"<ul> <li>Each $A[i]$ can start once in a column and possibly wrap once into the next column.</li> <li>Therefore, each $A[i]$ contributes at most two changes.</li> <li>This means the total number of operations is at most $2N$, not $\\text{lim}$.</li> </ul> <p>This compression is what makes the solution efficient and ensures $M \\cdot K \\leq 3 \\cdot 10^6$.</p>"},{"location":"editorials/PAIO%20TST%202025/gift/#step-5-correctness-argument","title":"Step 5: Correctness Argument","text":"<ol> <li>Sum condition ensures the total number of increments matches.</li> <li>Max condition ensures no element overflows beyond a single column boundary.</li> <li> <p>Because $A[i] \\leq \\text{lim}$, there is no overlap in rows:</p> </li> <li> <p>Every cell of the $\\text{lim} \\times K$ grid is covered by exactly one index.</p> </li> <li>The sweep construction outputs exactly the increments needed to reach $A$, with no waste.</li> </ol> <p>Therefore, the algorithm always finds a valid solution if and only if it exists.</p>"},{"location":"editorials/PAIO%20TST%202025/gift/#example","title":"Example","text":"<p>Input:</p> <pre><code>4 2\n2 3 3 2\n</code></pre> <ul> <li>$\\text{sum} = 10$, $\\text{lim} = 5$.</li> <li>Fill the $5 \\times 2$ grid column by column:</li> </ul> <pre><code>Column 1: [1, 1, 2, 2, 2]\nColumn 2: [3, 3, 3, 4, 4]\n</code></pre> <p></p> <ul> <li> <p>Sweep rows:</p> </li> <li> <p>Rows 1\u20132: active {1,3} \u2192 operation (2, 1 3)</p> </li> <li>Row 3: active {2,3} \u2192 operation (1, 2 3)</li> <li>Rows 4\u20135: active {2,4} \u2192 operation (2, 2 4)</li> </ul> <p>Output:</p> <pre><code>3\n2 1 3\n1 2 3\n2 2 4\n</code></pre>"},{"location":"editorials/PAIO%20TST%202025/gift/#implementation","title":"Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\ntypedef long long ll;\nusing namespace std;\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    vector&lt;ll&gt; a(n);\n    for (int i = 0; i &lt; n; i++)\n        cin &gt;&gt; a[i];\n    ll sum = 0;\n    ll max_ai = 0;\n    for (int i = 0; i &lt; n; i++) {\n        sum += a[i];\n        max_ai = max(max_ai, a[i]);\n    }\n\n    if(sum%k != 0 or max_ai &gt; sum/k){\n        cout &lt;&lt; \"-1\\n\";\n        return 0;\n    }\n\n    ll max_height = sum/k;\n    ll current_height = 0LL;\n    ll current_column = 0LL;\n\n    vector&lt;vector&lt;ll&gt;&gt; result;\n    vector&lt;tuple&lt;ll, ll, ll&gt;&gt; cache; // height, column, index\n    for (int i = 0; i &lt; n; i++){\n        cache.push_back({current_height, current_column, i+1});\n        current_height += a[i];\n        if(current_height &gt;= max_height){\n            current_height -= max_height;\n            current_column += 1;\n            if(current_column &lt; k)\n                cache.push_back({0, current_column, i+1});\n        }\n    }\n\n    cache.push_back({max_height, 0, 0});\n\n    sort(cache.begin(), cache.end());\n\n    current_height = 0LL;\n    vector&lt;ll&gt; current_move(k+1, 0);\n\n    for(auto &amp;[height, column, index] : cache){\n        if(height != current_height){\n            current_move[0] = height - current_height;\n            result.push_back(vector&lt;ll&gt;(current_move.begin(), current_move.end()));\n            current_height = height;\n        }\n\n        current_move[column+1] = index;\n    }\n\n    cout &lt;&lt; result.size() &lt;&lt; '\\n';\n    for(auto &amp;x : result)\n    {\n        for(auto y : x) cout &lt;&lt; y &lt;&lt; ' ';\n        cout &lt;&lt; '\\n';\n    }\n}\n</code></pre>"},{"location":"editorials/PAIO%20TST%202025/nelward/","title":"Nelward","text":"<p>Written by Redhouane Abdellah.</p>"},{"location":"editorials/PAIO%20TST%202025/nelward/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul>"},{"location":"editorials/PAIO%20TST%202025/nelward/#solution","title":"Solution","text":"<ul> <li> <p>Let \\(1 \\leq i &lt; j \\leq n\\) such that:</p> <ul> <li>\\(p_i &gt; p_j\\). Notice that \\(p_i\\) has to be moved in front of \\(p_j\\)     if we want to sort the permutation, meaning every element in     front of \\(p_i\\) also has to be moved.</li> </ul> </li> <li> <p>Let \\(1 \\leq k \\leq n\\) be the smallest index such that \\(p_k &lt; p_l\\)     for all \\(k &lt; l \\leq n\\).</p> <p>The previous observation tells us that all elements before \\(p_k\\) have to be moved, i.e.\u00c2the answer is at least</p> \\[ n - (n - k + 1) = k - 1 \\] </li> <li> <p>Notice how it is possible to move an element into any position when     performing an operation on it.</p> <p>We can do the following \\((k - 1)\\) times: move the first element into a new position \\(x \\geq k\\) such that the suffix starting at \\(k\\) stays sorted.</p> <p>Notice that after all operations the permutation is guaranteed to become sorted, hence the answer is always \\((k - 1)\\).</p> </li> </ul>"},{"location":"editorials/PAIO%20TST%202025/nelward/#implementation","title":"Implementation","text":"<ul> <li> <p>We can implement this in \\(O(n)\\) time and \\(O(n)\\) space by doing the     following:</p> <p>Traverse the array backwards starting from the \\((n-1)\\)th element, and set \\(k = n\\).</p> <p>As long as \\(p_i &lt; p_{i+1}\\) we keep traversing the array while decrementing \\(k\\) each time.</p> <p>As soon as the condition isn't met we stop decrementing \\(k\\) and traversing the array.</p> </li> </ul> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n; cin &gt;&gt; n;\n    vector&lt;int&gt; p(n);\n    for (auto &amp;i : p) cin &gt;&gt; i;\n    int k = n;\n    for (int i = n-2; i &gt;= 0; --i) {\n        if (p[i] &lt; p[i+1]) --k;\n        else break;\n    }\n    cout &lt;&lt; k-1;\n}\n</code></pre> <ul> <li> <p>We can reduce the space complexity to \\(O(1)\\) by doing the following:</p> <p>Set \\(k = 1\\), let \\(a = p_1\\).</p> <p>Then for all \\(1 &lt; i \\leq n\\): let \\(b = p_i\\).</p> <p>If \\(a &gt; b\\), we set \\(k = i\\) (because now the left endpoint of the longest increasing suffix is guaranteed to be \\(\\geq i\\)), and then set \\(a = b\\) before moving to \\(i+1\\).</p> <p>Here's the code for it:</p> </li> </ul> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n; cin &gt;&gt; n;\n    int a, b;\n    cin &gt;&gt; a;\n    int k = 1;\n    for (int i = 2; i &lt;= n; ++i) {\n        cin &gt;&gt; b;\n        if (a &gt; b) k = i;\n        a = b;\n    }\n    cout &lt;&lt; k-1;\n}\n</code></pre>"},{"location":"editorials/PAIO%20TST%202025/plane/","title":"Plane","text":"<p>Written by Haithem Djefel.</p>"},{"location":"editorials/PAIO%20TST%202025/plane/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul>"},{"location":"editorials/PAIO%20TST%202025/plane/#solution","title":"Solution","text":"<p>We can use a dynamic programming approach, let \\(dp_i\\) denote the minimum cost for omar to survive until minute \\(T_i\\), our base case is \\(dp_{-1} = 0\\), and our transition will be the following: </p> <p>For each \\(i \\in \\{0, 1,..., n - 1\\}\\), \\(dp_i = min(dp_{i - 1} + p, dp_{k - 1} + q)\\), where k is the index of the smallest \\(T_j\\) such that \\(T_j + m - 1 \\leq T_i\\). </p> <p>We visit each state exactly once, and at each state, we can find \\(dp_{i - 1}\\) in \\(O(1)\\), and \\(dp_{k - 1}\\) can be found in \\(O(\\log n)\\) using a binary search since the array \\(T\\) is sorted. our final answer will be \\(dp_{n - 1}\\). </p> <p>Now for the construction (i.e. finding the optimal way Omar should use the masks or perfume), this might seem tricky at first, but it could be done with just slight additions to our approach. </p> <p>We can treat our dp states as a DAG (directed acyclic graph), where each state is a node, and the parent for a state is the state that leads to it (i.e. choosing the mask or perfume); this way, we can start at state \\(n - 1\\) and continue traversing its parents until its first ancestor (state 0) \\ total time complexity: \\(O(n\\log n)\\)</p>"},{"location":"editorials/PAIO%20TST%202025/plane/#implementation","title":"Implementation","text":"<p>Below is an implementation of the aforementioned idea using a bottom-up dp approach:</p> <pre><code>cpp\n// PAIO TST solution code for planes by Haithem Djefel\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\ntypedef long long ll;\n\n#define Algerian ios::sync_with_stdio(0);\n#define OI cin.tie(0);\n\nint main() {\n    Algerian OI\n\n    ll n, m, p, q; \n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; q;\n    vector&lt;ll&gt; t(n);\n\n    for (ll i = 0; i &lt; n; i++) cin &gt;&gt; t[i];\n\n    vector&lt;ll&gt; dp(n);\n    vector&lt;ll&gt; par(n);\n\n    for (ll i = 0; i &lt; n; i++) {\n        dp[i] = (i &gt; 0 ? dp[i - 1] : 0) + p;\n        auto it = lower_bound(t.begin(), t.end(), t[i] - m + 1);\n\n        ll val = 0;\n        if (it != t.begin()) {\n            ll idx = (--it) - t.begin();\n\n            val = dp[idx];\n        }\n        val += q;\n\n        if (val &lt;= dp[i]) {\n            par[i] = 2;\n            dp[i] = val;\n        } else {\n            par[i] = 1;\n        }\n    }\n\n    cout &lt;&lt; dp[n - 1] &lt;&lt; \"\\n\";\n\n    ll x = n - 1;\n\n    vector&lt;ll&gt; res(n);\n\n\n    while (x &gt;= 0) {\n        if (par[x] == 1) {\n            res[x] = 1;\n            x--;\n        } else if (par[x] == 2) {\n            auto it = lower_bound(t.begin(), t.end(), t[x] - m + 1);\n            ll idx = it - t.begin();\n            res[idx] = 2;\n            x = idx - 1;\n        }\n    }\n\n    for (ll i = 0; i &lt; n; i++) cout &lt;&lt; res[i] &lt;&lt; \" \\n\"[i == n - 1];\n}\n</code></pre>"},{"location":"editorials/PAIO%20TST%202025/purchase/","title":"Purchase","text":"<p>Written by Fares Khelif.</p>"},{"location":"editorials/PAIO%20TST%202025/purchase/#problem-statement","title":"Problem Statement","text":"<ul> <li>English</li> <li>French</li> <li>Arabic</li> </ul>"},{"location":"editorials/PAIO%20TST%202025/purchase/#solution","title":"Solution","text":"<p>Naive Approach :  - For each suitcase, we compute the number of souvenirs we can fit with two nested for loops as shown in the pseudocode : <pre><code>vector&lt;int&gt; ans(M)\nfor(each Suitcase(of index j) in S) {\n    int elements = 0\n    int sum = 0\n    for (each Souvenir(of index i) in P) {\n         if (we can fit all souvenirs of weight i in the Suitcase) {\n             // Put all of them inside of it\n             sum += the weight of all elements\n             elements += P[i]\n         }\n         else {\n             // Put as much as we can inside of it\n             sum += the maximum weight we can fit inside of it\n             elements += the number of elements corresponding the the maximum weight\n        }\n     }\n     ans[j] = elements\n}\n</code></pre></p> <ul> <li>The main problem here is the time complexity :<ul> <li>For each Suitcase, we compute the maximum number of souvenirs we're able to put in it by iterating over all possible weights of the souvenirs</li> <li>Since we have T Suitcases and M possible weights of the Souvenirs, this will result in a TC of \\(O(T \\times M)\\) which is insufficient with such constraints(\\(10^5 \\times 10^5 = 10^{10}\\) (Too large!))</li> </ul> </li> <li> <p>Key Optimization :</p> <ul> <li>Instead of reiterating over all possible weights in P for every Suitcase, we can see that if we sort the array S while keeping the index of each suitcase for the output, we won't have to recompute computed suitecases, since we always start from the smallest weight, the large suitcase is going to fit what the small suitcase fitted, and it will still have the capacity to fit other souvenirs, and that's only what the optimized algorithm is going to compute</li> <li>As you can see the fully working code I wrote, which guarantees a 100%</li> </ul> </li> <li> <p>Time complexity: </p> <ul> <li>Since we don't recompute the previously computed weights, we have that i only does a single iteration over the array P which results in the fast : \\(O(T+M)\\)</li> <li>Which is guaranteed to work since \\(T, M \\leq 10^5\\), thus we have \\(2 \\times 10^5\\) operations at most</li> </ul> </li> </ul>"},{"location":"editorials/PAIO%20TST%202025/purchase/#implementation","title":"Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define endl '\\n'\nusing ll  = long long;\nusing pll = pair&lt;ll, ll&gt;;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //___________________________\n    ll t, m; cin &gt;&gt; t &gt;&gt; m;\n    vector&lt;ll&gt; s(t);\n    vector&lt;pll&gt; p(m);\n    for (ll i = 0; i &lt; t; i++) cin &gt;&gt; s[i];\n    for (ll i = 0; i &lt; m; i++) cin &gt;&gt; p[i].first, p[i].second = i;  // Essential step  No.1\n\n    sort(p.begin(), p.end());  // Essential step  No.2\n\n    vector&lt;ll&gt; ans(m);\n    ll i = 0; // Declare i as a global variable to not recompute computed values (avoids TLE)\n    ll sum = 0, el = 0;\n    for (ll j = 0; j &lt; m; j++) {\n        for (; i &lt; t; i++) {  // We don't need to declare i every time\n            if (p[j].first-sum &gt;= s[i]*i) { // If we can put all the weights in the suitcase\n                el += s[i];\n                sum += s[i]*i;\n                s[i] = 0;\n            }\n            else {  // If we can put some of it\n                ll a = ((p[j].first-sum)/i);\n                el += a;\n                sum += a*i;\n                s[i] -= a;\n                break;\n            }\n        }\n        ans[p[j].second] = el;  // Assign the answer to each suitcase\n    }\n\n    // Output the answers :\n    for (auto c : ans) cout &lt;&lt; c &lt;&lt; ' ';\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"math/proof-writing/","title":"Prove it !","text":"<p>Contribution by Said Kebir.</p> <p>To many students, mathematics is no more than finding numerical answers to problems. However, there is much more. Being able to prove your assertions is at least as important as finding the answer. Unfortunately, most schools neglect proofs or confine them to geometry classes, when proofs are important to all fields of mathematics. Moreover, proofs are usually presented in a dry, methodical way to emphasize rigor, when real mathematical proofs are written with more words than equations.</p>"},{"location":"math/proof-writing/#1-words-words-words","title":"1. Words, Words, Words","text":"<p>Proof problems and solutions have a special and subtle vocabulary of their own. Many of these terms confuse beginning students, so we'll go over them.</p> <ul> <li> <p>When a problem asks us to solve something about distinct objects or numbers, it means that the objects or numbers in question are all different. For example, if we are asked to solve a question involving 3 distinct integers, the numbers cannot be 2,3 , and 2 .</p> </li> <li> <p>When we say without loss of generality, we mean that we have chosen a specific case to solve, but the specific case really doesn't matter. By solving the assertion for that specific case, we prove it for all cases, as all cases are qualitatively the same; only the ordering of names or correlations is different.</p> </li> </ul> <p>EXAMPLE 1 Show that if \\(x+y+z=7\\) and \\(x, y\\), and \\(z\\) are distinct positive integers, then one of these numbers must be 4.</p> <p>Proof: Assume without loss of generality that \\(x&lt;y&lt;z\\). We can do this since we know the numbers are distinct and it doesn't really matter which is which. (While \\((1,2,4)\\) and \\((2,1,4)\\) are considered different solutions, they still consist of the same three numbers.) If \\(x=2\\), the sum \\(x+y+z\\) is at least \\(2+3+4=9\\), which is too big. Thus \\(x=1\\). Similarly, if \\(y=3\\), the sum is at least \\(1+3+4=8\\); thus, \\(y=2\\) and \\(z=4\\). Hence, one of the numbers (the largest) must always be 4 . By using \"without loss of generality\" as we have, we have just named the largest integer \\(z\\), the smallest \\(x\\), and the other \\(y\\). We can permute these labels in any way and the problem will be unchanged. Thus, all solutions can be found by permuting \\((1,2,4)\\).</p> <p>EXAMPLE 2 Why can't we use \"without loss of generality\" as above on a problem involving \\(x+2 y+3 z=1\\) ?</p> <p>Solution: The quantities in this problem are not interchangeable. Switching \\(x\\) and \\(z\\) yields \\(z+2 y+3 x=1\\), which is qualitatively different from the original \\(x+2 y+3 z=1\\). (For example, \\((x, y, z)=(1,0,0)\\) is a solution of one equation but not the other.) In the previous problem, switching \\(x\\) and \\(z\\) yields \\(z+y+x=7\\), which is not qualitatively different from \\(x+y+z=7\\). This is the heart of \"without loss of generality\"; changing the labels does not change the problem.</p> <ul> <li>In problems in which we are asked to maximize a quantity, we are actually asked to do two things. We must show that the maximum can be attained and that no value greater than that maximum can be attained. Just doing one of these is insufficient. The same, of course, holds for minimization.</li> </ul> <p>EXAMPLE 3 Find the maximum value of \\(x+y\\) if \\(x \\leq 3\\) and \\(y \\leq 5\\).</p> <p>Solution: Clearly \\(x+y\\) is always less than 9 , since \\(x+y \\leq 3+5\\). However, 9 is not the maximum, since it is never attained! The true maximum is 8 , since that is the largest value which can be attained.</p> <ul> <li> <p>A solution to a problem is called trivial if the numbers present in the problem have no use in determining that solution. Trivial solutions are those solutions which are blatantly obvious and have little mathematical value, so problems often ask the solver to find nontrivial solutions. For example, when solving the equation \\(x^{2}+y^{2}=z^{2},(0,0,0)\\) is a trivial solution. Generally, any solution in which all the variables equal 0 is a trivial solution. If on a test you are unsure whether a solution you have found is trivial or not, assume it is not trivial; if you had to think at all to find the solution, it probably isn't. As another example, when asked for the nontrivial factors of an integer, we want those factors besides 1 and the number itself.</p> </li> <li> <p>Sometimes proofs are so long that we want to break up the proof into smaller parts. After we prove each of these smaller parts, we combine them to complete the proof. In the text of a proof, these smaller parts are called lemmas. There aren't any proofs in this volume complicated enough to require lemmas, but there are some in the second volume. A proof is rigorous when the proof is complete with no unproven assumptions.</p> </li> <li> <p>A number is even if and only if it is divisible by two. Why do we say \"if and only if\" rather than just \"if\" or just \"only if?\" What is the difference? When we say a number is even if it is divisible by two, we do not exculde the possibility that a number which is not a multiple of two is even. By just saying a number is even only if it is divisible two, we don't say that all multiples of two are even. Only by combining the two in \"if and only if\" can we say both that a number must be a multiple of two to be even and that all multiples of two are even. Mathematicians often write \"iff\" rather than \"if and only if,\" so don't assume it's a typographical error.</p> </li> </ul> <p>EXERCISE 1 Do you need \"if,\" \"only if,\" or \"iff\" in the following?</p> <p>i. A number ends with a \\(5 \\ldots\\) it is divisible by five.</p> <p>ii. An animal is a mammal. . . it is a human.</p> <p>iii. A figure is a circle. . . every point on it is a common distance from some center.</p> <p>iv. A number is an integer... it has no fractional part.</p> <p>Proving facts involving if and only if usually requires two steps; the \"if\" and \"only if\" parts are generally proved separately. The examples at the end of this section will demonstrate this.</p> <ul> <li>That a number is a multiple of two is necessary and sufficient for the number to be even. \"Necessary and sufficient\" is just another way of saying \"if and only if.\" By \"necessary,\" we mean that it is necessary for a number to be a multiple of two in order to be even. As with \"only if,\" this does not imply that all multiples of two are even. By \"sufficient,\" we say that any multiple of two is even, but like \"if,\" this does not exclude numbers which are not multiples of two from being even. Only by putting together both of these can we say all multiples of two and only multiples of two are even. Once again, proofs of facts involving necessary and sufficient usually involve proving the two separately.</li> </ul> <p>EXAMPLE 4 Prove that the product of two integers is odd if and only if both of the integers are odd.</p> <p>Proof: To show the \"if\" part, we write our odd integers as \\(2 n+1\\) and \\(2 m+1\\). The product of these is \\((2 n+1)(2 m+1)=4 m n+2 m+2 n+1\\), which is odd because it isn't evenly divisible by two.</p> <p>To show the \"only if,\" we must show that the product of two even numbers and the product of an even number and an odd number are both even. First, letting the two even numbers be \\(2 n\\) and \\(2 m\\), the product is \\(4 m n\\), which is divisible by 2 . Second, letting the even number be \\(2 n\\) and the odd \\(2 m+1\\), the product is \\((2 n)(2 m+1)=4 m n+2 n\\), which is divisible by 2 and hence even. Thus the product of two integers is odd iff both the integers are odd.</p> <p>EXAMPLE 5 Show that \\(x\\) being a multiple of 3 is a necessary and sufficient condition for \\(x\\) to be a solution of \\(\\lfloor x / 3\\rfloor-x / 3=0\\).</p> <p>Proof: Write the equation as \\(x / 3=\\lfloor x / 3\\rfloor\\). Since \\(\\lfloor x / 3\\rfloor\\) is always an integer, \\(x / 3\\) must be an integer. Hence, it is necessary for \\(x\\) to be a multiple of 3 . To show that it is sufficient that \\(x\\) be a multiple of 3 , let \\(x=3 n\\) for some integer \\(n\\). Then \\(\\lfloor x / 3\\rfloor-x / 3=\\lfloor n\\rfloor-n=0\\), so all multiples of 3 are solutions to the equation \\(\\lfloor x / 3\\rfloor-x / 3=0\\).</p>"},{"location":"math/proof-writing/#2-contradiction","title":"2. Contradiction","text":"<p>Is too! Is not! Is too! Is not!</p> <p>This is an age old argument of children everywhere. Suppose you are arguing that something \"Is too!\" The most obvious way to show that it is such is to show that it is indeed true; however,</p> <p>there is another way. Instead of showing that you are right, show that your adversary is wrong. If our opponent is wrong, then you must be right. This is the heart of contradiction.</p> <p>A simple example of the use of contradiction is the proof that there are infinitely many prime numbers. Rather than try to prove that there are infinitely many primes directly, we prove that the opposite is impossible-i.e., it is impossible that there is a finite number of primes.</p> <p>EXERCISE 2 review the proof that there are infinitely many primes.</p> <p>EXAMPLE 6 Prove that if \\(x\\) is a real solution to \\(x^{5}+3 x^{2}+7 x+2=0\\), then \\(x\\) must be negative.</p> <p>Proof: First, \\(x=0\\) is clearly not a solution. Second, if \\(x&gt;0\\), then \\(x^{5}+3 x^{2}+7 x+2\\) is the sum of four positive terms and hence cannot be equal to zero. Thus no positive \\(x\\) can be a solution to the equation. Hence, we have shown by contradiction that if \\(x\\) is a solution to the given equation, it cannot be nonnegative, so any real solution \\(x\\) must be negative.</p> <p>EXERCISE 3 Prove that if \\(a, b, c&gt;0\\), then if \\(a x^{2}+b x+c=0\\) has real solutions, both solutions are negative.</p>"},{"location":"math/proof-writing/#3-converses-arent-necessarily-true","title":"3. Converses Aren't Necessarily True","text":"<p>All dogs have noses; therefore, anything with a nose is a dog. Clearly this argument is ridiculous; however, people will often give arguments like this to prove mathematical facts.</p> <p>Given a statement like \"If an animal is a dog, then it has a nose,\" the converse of the statement is \"If an animal has a nose, then it is a dog.\" Notice that we have just swapped the positions of \"dog\" and \"nose;\" that is what the converse is. The inverse is \"If an animal is not a dog, then it does not have a nose\"; we have just negated \"nose\" and \"dog.\" The contrapositive is \"If an animal does not have a nose, the animal is not a dog.\" Here we have both swapped \"dog\" and \"nose\" and negated them.</p> <p>From our examples, it is clear that if a statement is true, its converse and inverse are not necessarily true. Indeed, the converse and inverse of our sample statement about dogs' noses are quite ridiculous. The contrapositive of a true statement, however, is always true. Do you see why?</p> <p>While it important to understand that the contrapositive of a statement is always true, it is equally important to see that the converse may or may not be true. Hence, when asked to prove a statement which is the converse of a true statement, the original statement is irrelevant. You must prove the converse separately.</p> <p>EXAMPLE 7 What are the converse, inverse, and contrapositive of the statement, \"If Jim is outside, it is raining?\" Which of these must be true if the statement is true?</p> <p>Solution: The converse is \"If it is raining, Jim is outside.\" The inverse is \"If Jim is not outside, it is not raining.\" The contrapositive is \"If it is not raining, Jim is not outside.\" The contrapositive is the only one which must be true if the statement is true.</p>"},{"location":"math/proof-writing/#4-mathematical-induction","title":"4. Mathematical Induction","text":"<p>Mathematical induction is a powerful tool when we are asked to prove something is true for integers. It works like this. Suppose we are asked to prove that a given assertion is true for all positive integers. First, we show that it is true for 1 (or some other base case, often 0 ). Second, we show that if it is true for some integer \\(k\\), then it must be true for the number \\(k+1\\). This is the inductive step. Having proved this we argue that, since it is true for 1 , it must be true for \\(1+1=2\\). Since it is true for 2 , it is true for \\(2+1=3\\), and so on. Thus the assertion is true for all positive integers.</p> <p>For example, let's show that</p> \\[ 1+2+3+\\cdots+n=\\frac{n(n+1)}{2} \\] <p>First, we show it is true when \\(n=1\\). This is obvious, as</p> \\[ 1=\\frac{1(1+1)}{2} \\] <p>Now, we show that if it is true for \\(k\\), it must also be true for \\(k+1\\). If the assertion is true for \\(k\\), we have</p> \\[ 1+2+3+\\cdots+k=\\frac{k(k+1)}{2} \\] <p>Now, we must evaluate the sum of the integers from 1 to \\(k+1\\) :</p> \\[ \\begin{aligned} 1+\\cdots+k+(k+1)=(1+\\cdots+k)+(k+1) &amp; =\\frac{k(k+1)}{2}+(k+1) \\\\ &amp; =\\frac{k}{2}(k+1)+(k+1) \\\\ &amp; =\\left(\\frac{k}{2}+1\\right)(k+1) \\\\ &amp; =\\frac{(k+1+1)(k+1)}{2} \\end{aligned} \\] <p>Thus, we have shown that if</p> \\[ 1+2+3+\\cdots+n=\\frac{n(n+1)}{2} \\] <p>is true for \\(n=k\\), then it is true for \\(n=k+1\\). Since it is true for \\(n=1\\), it is therefore true for \\(2,3,4, \\ldots\\), that is, all positive integers.</p> <p>Ordinarily when using induction, we don't have to explain \"Since it is true for...\" We must merely prove the initial case, prove the inductive step, then assert that the induction is complete. The following example is a model of the use of induction as it should appear in texts, or on test papers.</p> <p>EXAMPLE 8 Show that for all positive integers \\(n\\),</p> \\[ 7+6 \\cdot 7+6 \\cdot 7^{2}+6 \\cdot 7^{3}+\\cdots+6 \\cdot 7^{n}=7^{n+1} \\] <p>Proof: For \\(n=1\\), we have \\(7+6 \\cdot 7=49=7^{1+1}\\), so the assertion is true for \\(n=1\\). If the assertion is true for \\(n=k\\), we have</p> \\[ 7+6 \\cdot 7+6 \\cdot 7^{2}+6 \\cdot 7^{3}+\\cdots+6 \\cdot 7^{k}=7^{k+1} \\] <p>Thus,</p> \\[ \\begin{aligned} 7+6 \\cdot 7+\\cdots+6 \\cdot 7^{k+1}=\\left(7+6 \\cdot 7+\\cdots+6 \\cdot 7^{k}\\right)+6 \\cdot 7^{k+1} &amp; =7^{k+1}+6 \\cdot 7^{k+1} \\\\ &amp; =(1+6) 7^{k+1} \\\\ &amp; =7^{k+1+1} \\end{aligned} \\] <p>This proves the inductive step and our induction is complete.</p> <p>EXERCISE 4 Consider the following \"proof\" that every person in the world is the same height. Step one: In a group of 1 , every person is the same height. Step 2: Given that in any group of \\(k\\) people the people are all the same height, we show that any group of \\(k+1\\) people must consist of people who are all the same height. We do this as follows. Given a group of \\(k+1\\) people, we remove one. The other \\(k\\) must be the same height, since they are a group of \\(k\\) people. Now replace the removed person and take someone else out. This also leaves a group of \\(k\\) people of the same height including the first removed person. This person is then the same height as the other \\(k\\). Hence, any group of \\(k+1\\) people is a group of people who are all the same height. This completes the inductive step, so all people are the same height.</p> <p>Clearly something is wrong with this. What?</p>"},{"location":"math/proof-writing/#5-shooting-holes-in-pigeons","title":"5. Shooting Holes in Pigeons","text":"<p>Consider a flock of \\(n+1\\) pigeons. Due to space constraints, the pigeons' home only has \\(n\\) holes (bear with us). If the flock flies home for the summer, there must be at least one hole with 2 or more pigeons in it. Do you see why?</p> <p>This is the simplest statement of the Pigeonhole Principle. (It is also called Dirichlet's Principle, probably because he was the first to realize that such an obvious theorem could be useful.) In fact, the Principle is highly useful in math, especially in nonobvious settings.</p> <p>EXAMPLE 9 Given 7 points on a line segment of length 1, prove that there must exist two of the points separated by no more than \\(1 / 6\\).</p> <p>Proof: Divide the line segment into six equal length segments. By the Pigeonhole Principle, two of the points must lie on one of these segments (including endpoints). These two points will be at most \\(1 / 6\\) apart, because they lie on a segment of length \\(1 / 6\\).</p> <p>The hardest part of applying the Principle, besides realizing that it might be useful to the problem at hand, is determining the pigeonholes. They will almost invariably be simple, like dividing an interval into equal pieces or a square into equal squares.</p> <p>The version of the Principle we are using is a little too weak for general use. We can easily strengthen it by modification. Consider a flock of \\(2 n+1\\) pigeons, with the same \\(n\\) holes. Now there must be some hole with at least three pigeons. The general statement and the easy proof are as follows.</p> <p>The Pigeonhole Principle. Given \\(k n+1\\) objects which are in \\(n\\) boxes, there must be some box with at least \\(k+1\\) objects.</p> <p>Proof: We use the principle of proof by contradiction. Suppose that the \\(n\\) boxes each have \\(k\\) or fewer objects. The total number of objects is then less than or equal to \\(n k\\). But the total number is given to be \\(n k+1\\), so this gives \\(n k+1 \\leq n k\\), a contradiction. So our original supposition that there was no box with \\(k+1\\) or more objects must be false.</p> <p>The Pigeonhole Principle crops up in a surprising variety of disguises. With some experience, you should learn to identify them.</p> <p>EXERCISE 5 A group of \\(n\\) people are selecting entrees at a restaurant. All the entrees are either pasta, seafood, beef, chicken, or vegetarian. Find the smallest possible \\(n\\) such that we can be sure that at least 3 people have dishes from the same category. Prove your answer.</p>"},{"location":"math/proof-writing/#6-convincing-but-wrong","title":"6. Convincing But Wrong","text":"<p>When you compare a proof you have written for a problem to one offered as the \"right\" proof, you will often find that yours is different from the proposed solution. However, don't assume your proof is wrong. Unlike \"find the answer\" questions, proofs have many different right answers.</p> <p>Unfortunately, they also have many wrong ones. And no matter how convincing it is, a wrong proof is still wrong. For this reason, if your proof differs from the \"correct\" solution, don't automatically assume your proof is just a different way to solve the problem. Challenge your solution; check each link in your chain of reasoning to make sure it is sound.</p> <p>In this section we discuss convincing but wrong arguments. We'll begin by proving that \\(-1=1\\), starting from \\(1+1=2\\). Our steps are as follows: \\(1+1=2\\), so \\(1-2=-1\\), so \\((1-2)^{2}=(-1)^{2}\\), so \\((1-2)^{2}=1\\), so \\(\\sqrt{(1-2)^{2}}=\\sqrt{1}\\), so \\(1-2=1\\), so \\(-1=1\\). Clearly our conclusion, \\(-1=1\\), is wrong, but our premise, \\(1+1=2\\), is correct. So one of our steps must be faulty. Analyzing our \"proof\" closely, we see that our erroneous step is going from \\(\\sqrt{(1-2)^{2}}=\\sqrt{1}\\) to \\(1-2=1\\). We have taken the negative square root on the left rather than the positive square root. The moral of the story? It is easy to hide a wrong step amidst a barrage of correct ones.</p> <p>Convincing but wrong proofs often include showing patterns without proving them. Recognizing a pattern is essential to problem solving, but noting that a pattern exists does not constitute a proof.</p> <p>For example, suppose we are asked to find a closed form for</p> \\[ 2^{0}+2^{1}+2^{2}+\\cdots+2^{n} \\] <p>(A closed form for a sum is one which can be immediately evaluated by plugging in the variable; there can be no summations left.) If we evaluate the sum for \\(n=1,2\\), and 3 , we find that the answers are \\(2^{2}-1,2^{3}-1\\), and \\(2^{4}-1\\), respectively. From these results, we might try to deduce that a general closed form for the sum is \\(2^{n+1}-1\\). But this is no proof. Seeing a pattern of this type is important in finding a general rule, but not in proving it.</p> <p>A common mistake in wrong proofs is circular reasoning. Circular reasoning occurs when we use a statement to prove itself. This may sound easy to avoid, but as the following examples show, a circular assumption can be buried very deeply; in working a complex problem it is easy to forget which statements you know and which you are trying to prove.</p> <p>EXAMPLE 10 What's wrong with the following \"proof\"?</p> <p>Suppose 5 women and 5 men are seated at a round table such that each person sits between 2 people of the opposite sex. We shall prove that if we number the chairs from 1 to 10 in order, a woman must be seated in chair 1.</p> <p>If a woman is in chair 1, a man must be in chair 2, so a woman must be in chair 3, and so forth, until we conclude that a man is in chair 10. Since chair 10 is next to chair 1, a woman must be in chair 1 .</p> <p>Solution: We wish to show that a woman is in chair 1, but our first step in the erroneous proof assumes that a woman is in chair 1 . We are guilty of circular reasoning-we must not in any step assume what we are trying to prove is true.</p> <p>EXAMPLE 11 What's wrong with this proof that if \\(|x|+x&gt;0\\), then \\(x&gt;0\\) ?</p> <p>Since \\(|x|=x\\), then \\(|x|+x=2 x\\). Thus \\(2 x&gt;0\\), so \\(x&gt;0\\).</p> <p>Solution: This example shows that circular reasoning can be used to prove a true statement incorrectly. Our first step in the \"proof\" is \\(|x|=x\\); but this is only true if \\(x \\geq 0\\) ! Thus in writing \\(|x|=x\\), we assume that \\(x \\geq 0\\), which is what we are trying to prove. Again we are guilty of circular reasoning. (Among the problems at the end of this chapter, the reader is challenged to find a sound proof for the assertion of this problem.)</p> <p>EXERCISE 6 Find what's wrong with the following proof and provide a sound alternative.</p> <p>There are 21 students in a ten minute class. Each student sleeps for a total of 1 minute during the class. Prove that there is some moment when at least three students are asleep.</p> <p>Proof: Two students sleep during the first minute, two during the second, and so on, for a total of 20 students sleeping for a minute during the 10 minute class. The remaining student must sleep during one of these minutes as well, so there must be 3 students sleeping during the same minute.</p>"},{"location":"math/proof-writing/#7-problems-to-solve","title":"7. Problems to Solve","text":"<ol> <li> <p>Prove that if \\(n\\) is an integer satisfying \\(n^{4}+4 n^{3}+3 n^{2}+n+4000=0\\), then \\(n\\) must be even.</p> </li> <li> <p>In one of the examples in this chapter, we showed that if \\(x\\) is a real solution to \\(x^{5}+3 x^{2}+7 x+2=0\\), then \\(x\\) must be negative. Why can't we say that \\(x\\) is a solution to this equation if and only if \\(x\\) is negative?</p> </li> <li> <p>Show that for all integers \\(n\\) greater than \\(2,1+2+3+\\cdots+n\\) is a composite number.</p> </li> <li> <p>Given 11 points, no four of which are coplanar, each triangle formed by three of the points is given a letter \\(A, B, C\\), or \\(D\\). At most how many triangles must get the same letter? (Mandelbrot #1)</p> </li> <li> <p>Show that if \\(x / y\\) and \\(y / x\\) are both integers, then \\(|x|=|y|\\).</p> </li> <li> <p>Explain the proposed paradox in the following story. Three men rent a hotel room. They are charged 15 dollars each. Later, the manager decides they should only have been charged 40 dollars for the room, so he gives 5 dollars to a messenger to give to the men. The messenger dishonestly keeps two dollars and gives each man 1 dollar. Each man has paid 14 dollars for the room and the messenger has 2 dollars, for a total of 44 dollars; however, the men originally paid 45 dollars for the room. Where's the other dollar?</p> </li> <li> <p>Prove that if \\(|x|+x&gt;0\\), then \\(x\\) must be positive.</p> </li> <li> <p>Chairs are equally spaced around a table and numbered from 1 to \\(2 n\\). Prove that if every odd chair is directly opposite another odd numbered chair, then the number of chairs is a multiple of 4 .</p> </li> <li> <p>Prove that between any two consecutive multiples of 7 , exclusive, there are exactly two multiples of three.</p> </li> <li> <p>Given three lines through the origin, prove that there must be a pair of them which form an angle of less than or equal to \\(60^{\\circ}\\).</p> </li> <li> <p>Show that $$ \\frac{1}{1 \\cdot 2}+\\frac{1}{2 \\cdot 3}+\\cdots+\\frac{1}{n \\cdot(n+1)}=\\frac{n}{n+1} $$</p> </li> <li> <p>Prove that a number has an odd number of distinct factors if and only if the number is a perfect square.</p> </li> <li> <p>Three women are in a round-robin tennis tournament in which they each play each other player once. Prove that at least one player must lose one game and win one game.</p> </li> <li> <p>Show that \\((1+2+3+\\cdots+n)^{2}=1^{3}+2^{3}+3^{3}+\\cdots+n^{3}\\).</p> </li> <li> <p>A drawer contains 8 grey socks, 5 white socks, and 10 black socks. If socks are randomly taken from the drawer without replacement, how many must be taken to be sure that 4 socks of the same color have been taken? (MATHCOUNTS 1988)</p> </li> <li> <p>A woman has written \\(k\\) letters and addressed \\(k\\) envelopes for them. She then randomly puts the letters in the envelopes. Show that the number of letters which are put in the proper envelope can be any number from 0 to \\(k\\) except \\(k-1\\).</p> </li> <li> <p>Prove that \\(n^{5}-n\\) is divisible by 10 for all integers \\(n\\).</p> </li> <li> <p>Each of 6 points in space is connected to the other 5 points by line segments. Each segment thus formed is colored green or purple. Show that it is impossible to color all the segments without forming a triangle in which all three segments are the same color.</p> </li> </ol> <p>the BIG PICTURE</p> <p>To mathematicians, a proof is more than just a confirmation of the truth of an already wellunderstood principle; it shows a true understanding of the principle, and conveys an aesthetic value.</p> <p>For this reason, people interested in math delight in coming up with proof after proof of a result. Each new proof shows a different facet of the theorem, a geometric or algebraic or topological or analytic or differential facet. For example, Karl Friedrich Gauss, one of the greatest mathematicians ever, had around six different proofs for the Fundamental Theorem of Algebra and multiple proofs of other important theorems. Throughout history, proofs of the Pythagorean Theorem, proofs that the area of a circle is indeed \\(\\pi r^{2}\\), and proofs of the Angle Bisector Theorem have all enriched their subjects.</p> <p>People have always sought to find the simplest, most elegant way to prove a theorem. The Mathematical Association of America's Mathematics Magazine even has a section devoted to this principle, in which a proof must consist only of a revealing diagram and a few equations. The most beautiful proof I know of the Pythagorean Theorem, discovered by an ancient Hindu mathematician, consisted only of the diagram and one word: BEHOLD! Developing proofs of this type is an excellent exercise, but don't overdo it, or your proofs will soon be unreadable.</p>"},{"location":"math/proof-writing/#resources","title":"Resources","text":""},{"location":"math/proof-writing/#videos","title":"Videos","text":"<ul> <li> <p>Introduction to Proof Writing -- Full Course!!!  (en)</p> </li> <li> <p>Intro To Math Proofs (Full Course) (en)</p> </li> <li> <p>Proofs by AMO (ar)</p> </li> <li> <p>Principles of Logic and Patterns of Proof (ar)</p> </li> </ul>"},{"location":"math/proof-writing/#pdfs","title":"PDFs","text":"<ul> <li> <p>Book of Proof (en)</p> </li> <li> <p>Writing up solutions Ed Barbeau (en) (french)</p> </li> <li> <p>Advice for writing proofs Evan Chen (en)</p> </li> </ul>"},{"location":"math/proof-writing/#bonus","title":"Bonus","text":"<ul> <li>Math's Fundamental Flaw  (en)</li> </ul>"}]}